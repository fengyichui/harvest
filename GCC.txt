
=== GCC and it's toolbox ===


1. 最小化Code size (去除无用的数据和函数)： >
    CC_OPT = -Os -flto -fdata-sections -ffunction-sections
    LD_OPT = -Wl,--gc-sections
    gcc $(CC_OPT) test.cpp -o test $(LD_OPT)

2. objcopy
    bin -> ihex >
    $ objcopy --change-addresses 0x08000000 -I binary -O ihex a.bin a.hex
<    ihex -> bin >
    $ objcopy -I ihex -O binary a.hex a.bin
<    elf -> ihex >
    $ objcopy -O ihex a.elf a.hex
<    elf -> bin >
    $ objcopy -O binary a.elf a.bin
<
    NOTE: 如果elf产生的ihex或bin文件过大的话，可以对objcopy使用-j选项来指定产生文件的section： >
    $ objcopy -j .text -O binary a.elf a.bin

3. objdump
    elf -> disassemble >
    objdump -d a.elf > a.dis
<    binary -> disassemble (ARM cortex-m3 thumb) >
    arm-none-eabi-objdump -D -b binary -m arm -M force-thumb a.bin > a.dis

4. readelf
    读取elf文件头信息, 包括ENTRY等 >
    readelf -h a.elf
<    NOTE: GDB会自动在load程序之后把ENTRY值赋给$PC指针

5. arm-none-eabi-gcc, printf, malloc
    arm gcc 的newlib库在调用malloc、printf等函数时，需要 *_sbrk()* 系统调用，
    默认的weak声明的_sbrk()直接使用linker脚本里的 *end* 符号(但是这样不安全)。

6. GDB
    gdb [options] --args executable-file [inferior-arguments ...] ~
    options: ~
         --symbols=SYMFILE  从指定文件中读取符号表。
         --directory=DIR    加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。
         --nx               忽略.gdbinit 文件

    初始化: ~
         gdb初始化时候会主动读取 ~/.gdbinit 文件，并把它作为初始化文件
         常用选项：
             set confirm off                         # 取消confirm
             set verbose off                         # 详细输出禁止
             set history filename ~/.gdb_history     # 历史记录
             set history remove-duplicates unlimited # 去除重复的历史记录
             set history save on                     # 存储历史记录
             set pagination off                      # 取消滚屏时候的提示(取消类似more命令的提示)
             set print pretty on                     # 漂亮的打印
             set print elements 0                    # 打印大数组时，不限制个数
             set print array on                      # 漂亮的打印数组
             set output-radix 0x0A                   # 10进制输出
             set input-radix 0x0A                    # 10进制输入
             set arm force-mode thumb                # 强制使用thumb模式

    编译要求: ~
         使用编译器(cc/gcc/g++)编译的时候加上 -g 选项，它可以把调试信息加入到可执行文件中去。如：> cc -g hello.c -o hello
         -g与-ggdb区别：
            -g         利用操作系统的nativa format生成调试信息
            -ggdb      专门为GDB生成更为丰富的调试信息，但不能使用其他调试器调试了
         级别(同样适用于-ggdb)：
            -g1        不包含行号和局部变量的调试信息
            -g2        默认级别，此时产生的调试信息包括扩展的符号表，行号，变量表
            -g3        包含g2的所有信息，以及源代码中定义的宏
         所以常用-ggdb3作为编译选项

         调试KEIL编译的axf：
            keil的编译选项需要加上：--dwarf2
            因为keil默认使用Dwarf3，但是gdb对Dwarf2支持较好

    调试命令: ~
         一般:
             load <elf-file>  加载elf文件和符号
             l  [list]        列出当前程序执行点前后的程序源码
             bt [backtrace]   查看调用栈
             up               向上移动栈
             down             向下移动栈
             f  [frame]       会打印出：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数 执行到的语句。
             info f           会打印出更详细的栈信息
             info locals      打印出当前函数中所有局部变量及其值
             disassemble func 反汇编
             q  [quit]        退出
             set args (eg: set args 10 20 30 40 50) 指定运行时main()的参数
             macro expand I_AM_A_MACRO 显示宏的值

        Restore和Dump数据
             restore <hex-file>                     加载hex文件
             restore <bin-file> binary <address>    加载bin文件到指定地址
             dump memory <file> <begin> <end>       dump bin文件
             dump ihex memory <file> <begin> <end>  dump hex文件

         运行与调试:
             r  [run]      (重新)运行程序
             c  [continue] 继续
             s  [step]     单步，进入函数
             si [stepi]    单步跟踪一条机器指令
             n  [next]     单步，不进入函数
             ni [nexti]    单步跟踪一条机器指令
             finish        跳出当前函数
             u  [until]    跳出当前循环

         断点(breakPoint):
             b [break]:
                  b <function>     (eg: b main)     断点设置到main
                  b <linenum>      (eg: b 15)       断点设置到当前文件的第15行
                  b <+/-offset>    (eg: b +10)      断点设置到当前行+10的位置
                  b if <condition> (eg: b if i=10)  当i=100的时候停住
                  b <where> if <condition> (eg: b func if i=10)
                  b <filename:linenum> (eg: b a.c:10)
             info break：查看已经存在的断点     
             clear 清除所有断点
             clear <function>      (eg: clear main) 清除函数上的断点
             delete <breakpoints>  (eg: delete 2)   清除断点号为2的断点
             disable <breakpoints> (eg: disable 2)  暂时disable断点号为2的断点

         观察点(WatchPoint)
             watch <expr>     (eg: watch var)  为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。
             rwatch <expr>    (eg: rwatch var) 当表达式（变量）expr被读时，停住程序。
             awatch <expr>    (eg: awatch var) 当表达式（变量）的值被读或被写时，停住程序。
             info watchpoints 列出当前所设置了的所有观察点。
             example: >
             $ watch *0x2000A000 #当内存0x2000A000的值改变时，触发断点
             $ watch llc_env     #当内存llc_env整个类型的值改变时，触发断点
<
         查看运行时数据
             p [print]: 查看变量 (优先查看局部变量)
                 p <expr>             (eg: p var)        十进制查看变量var的值
                 p /<fmt> <expr>      (eg: p /x var)     带格式化的查看变量var的值(十六进制)
                 p <$reg>             (eg: p $pc)        查看寄存器PC的值
                 p file::variable     (eg: p 'a.c::var') 查看a.c中变量var的值，优先查看全局变量
                 p function::variable (eg: p main::var)  查看mian()中变量var的值
                 p *pdata@len         (eg: p *pdata@10)  查看数组且长度为10的内容, *是重要的
                 p array              (eg: p array)      查看固定数组所有内容

             x [examine]: 查看内存数据
                  x/<n/f/u/i> <addr> (eg: x /10xh 0x40001000) 从内存地址为0x40001000处读取10个双字的数据 
                       <n> 读取字符个数
                       <f> 格式化
                       <u> 字符大小 b单字节 h双字节 w四字节 g八字节
                       <i> 反汇编 (eg:x /8i $PC - 16)
                  使用print查看内存。优点：长度可以用变量
                       p /x *((uint32_t *)0x20000000)@10
                       p /x *((uint8_t *)0x20000000)@length

             display: 自动显示内存变量数据, 单步或者断点后自动显示
                 display <expr>       (eg: display var)
                 display/<fmt> <expr> (eg: display /x var)
                 display/<fmt> <addr> (eg: display /x 0x40001000)
                 undisplay <dnums...>
                 info display

             关于格式化字符 <fmt>:
                 x  按十六进制格式显示变量。
                 d  按十进制格式显示变量。
                 u  按十进制格式显示无符号整型。
                 o  按八进制格式显示变量。
                 t  按二进制格式显示变量。 
                 a  按十六进制格式显示变量。
                 c  按字符格式显示变量。
                 f  按浮点数格式显示变量。

         改变程序的执行:
             set var <var>=<value> (eg: set var width=100) 设置变量width为100
             jump <linespec>       (eg: jump 12)           强制跳转到指定行
             jump <address>        (eg: jump 0x10000004)   强制跳转到指定地址
             call <expr>           (eg: call main)         强制调用一个函数
             return 强制跳出当前函数

         查看寄存器
             info registers 查看寄存器的情况。（除了浮点寄存器）
             info all-registers 查看所有寄存器的情况。（包括浮点寄存器）
             info registers <regname ...> 查看所指定的寄存器的情况。

         修改内存值：
             set *(int *)pointer = value

         定义环境变量
             set $<var> = <value> (eg: set $i=0) 设置变量
             p $<var>             (eg: p $i)     查看变量值
             p $                                 上一次使用的变量
             show convenience 查看所有变量

         查看数据结构offset和size：
            ptype /o <struct>

         命中断点时候自动执行命令：
             (gdb) command 6 //6是断点号。如果没有断点号，则默认使用上面紧跟的断点
             Type commands for breakpoint(s) 6, one per line.
             End with a line saying just "end".
             >x /2xw 0x4001A030 
             >x /4xw 0x4001A020 
             >x /1xw 0x4001A038 
             >x /1xw 0x4001A03c 
             >x /1xw 0x4001A200 
             >x /10xw 0x4001A204
             >x /10xw payload    
             >end //结束

         执行shell程序：
             shell ls  #执行shell的ls程序，即 shell 命令
             cd        #可以直接执行
             make      #可以直接执行
             pwd       #查看当前所在的目录

         连接断开远程调试：
             连接：target remote 192.168.1.160:2331
             断开：kill

        启用仿真模式SIM：
            file a.axf
            target sim
            load
            run

         加载符号：
            file <file>:
                加载并覆盖文件内的符号，并把该文件作为执行文件。没有参数的含义：删除已有的符号和执行文件
            symbol-file <file>:
                仅加载并覆盖文件内的符号，不加载该文件作为执行文件
            exec-file <file>:
                仅把该文件作为可执行文件，不加载符号
            add-symbol-file <file> <address>:
                仅加载并附加文件内的符号，不加载该文件作为执行文件

         重定位源文件：
            directory <dir>
                添加新的源文件搜索目录，ELF内的文件位置为相对文件位置时使用
            set substitute-path <old-dir> <new-dir>
                修改旧的绝对目录为新的目录
                $ set substitute-path E:/2-svn/ble_asic/rom/ /home/lenovo/tags/hs6620_rom_a0_release/rom
            info source
                查看当前文件位置
            info sources
                查看所有文件位置

         线程：
            info threads                    显示当前可调试的所有线程
            thread ID(1,2,3…)               切换当前调试的线程为指定ID的线程
            break file.c:123 thread all     在所有线程中相应的行上设置断点
            thread apply ID1 ID2 command    让一个或者多个线程执行GDB命令command
            thread apply all command        让所有被调试线程执行GDB命令command
            set scheduler-locking off       不锁定任何线程，也就是所有线程都执行，这是默认值
            set scheduler-locking on        只有当前被调试程序会执行
            set scheduler-locking on step   在单步的时候，只有当前线程会执行

        调试PIC文件：
            file a.axf -o 0x1000               -o 指定PIC文件加载的offset
            add-symbol-file a.axf -o 0x1000

    ~/.gdbinit 语法： ~
         默认情况gdb会在初始化的时候加载该文件。
         定义函数：define
              define conncet
              target remote 192.168.1.160:2331
              end
         非define定义的函数，gdb会在初始化的时候自动执行。

    GDB自动调试脚本 ~
        gdb加载脚本的方式有
            gdb -x script
            gdb命令: source script

        条件控制语句：
            if (id==10)
            end

            if (id==10)
            else
            end

            while (id)
                loop_break
                loop_continue
            end

        变量
            set $var = 100
            set $var += 10
            set $var++

        打印：
            echo text                       # 仅打印出text的字面内容
            output expression               # 输出expression的友好结果，类似p打印，只不过不会输出"$n = xxx"
            output /fmt expression          # 输出expression的格式化结果，类似p打印，只不过不会输出"$n = xxx"
            printf string, expressions...   # 格式化输出，用法同c语言的printf，但是当输出%s，可能会有问题（需要调试程序里有malloc的函数）

        执行字符串：
            eval "format_string", arg1, arg2, arg3, ..., argn   # 转换 printf "format_string", arg1, arg2, arg3, ..., argn 为一个命令行，然后调用它

        TIPS:
            默认遇到执行失败的命令就会退出脚本，可以使用 "(gdb) ignore-errors <command>" 来忽略某个命令的错误

        example: >
        (gdb) source test.gdb
        (file) test.gdb:
            file test.bin
            set logging on gdb.log
            set $var = 0
            break function
            command
                p $pc
                frame
                info register
                while($var < 100)
                    set $var++
                    printf "%08X\n", $var
                end
                c
            end
            run
<
    GDB 问题处理:
        1. 如果打印某个符号时发现GDB报如下错时： >
            No symbol "HS_PMU" in current context.
<           a. 可以使用"list"命令，选择该符号所在的上下文，如：l main;
           b. 将PC指针设置到改符号的上下文中，如：set $pc=main
           原因是GDB在解析某个符号时,必须要求该符号在要求的上下文中。(某些宏和变量和函数可以用static声明)
           注意：变量可以使用'file'::var的方式声明作用域，但是宏不行

    在Cortex-M系列芯片的Hardware Fault时，GDB的backtrace不能工作的问题：
        GDB没有考虑到ARM的中断机制, 修复步骤： >
        set $lr=*(unsigned int *)($sp+20)
        set $pc=*(unsigned int *)($sp+24)
        set $xpsr=*(unsigned int *)($sp+28)
        set $sp=$sp+32
        bt


7. 使用GDB调试KEIL产生的AXF文件:
    使用GDB调试原始的keil的AXF文件有功能性问题
    This happens because of the differences between
    the GNU and the Keil linker. The GNU linker computes 2
    different addresses for the data section: the address where
    it will be loaded (VMA) and the address in the FLASH memory
    where its contents will be stored (LMA). GDB then puts the
    section contents at the LMA address and the startup code
    copies it to VMA. Keil linker sets the LMA = VMA, so instead
    of writing the data section to FLASH, GDB puts it directly
    into RAM where it gets overwritten by the Keil statup code
    that expects it to be in the FLASH. To fix this we first
    need to find out the section name.
    Run arm-eabi-objdump.exe -x <ELF FILE> on your ELF file (objdump tool is a part of the GCC toolchain):

    keil axf objdump: >
    Idx Name   Size      VMA       LMA       File off  Algn
    0 ER_RO    0000168c  08000000  08000000  00000034  2**2
               CONTENTS, ALLOC, LOAD, READONLY, CODE
    1 ER_RW    00000020  20000000  20000000  000016c0  2**2  ----->相同<-----
               CONTENTS, ALLOC, LOAD, DATA
    2 ER_ZI    00000660  20000020  20000020  000016e0  2**3
               ALLOC
<    gcc axf objdump: >
    Idx Name   Size      VMA       LMA       File off  Algn
    0 .text    00018f40  08000000  08000000  00008100  2**2
               CONTENTS, ALLOC, LOAD, READONLY, CODE
    1 .data    000002b0  2000b000  08019048  00023000  2**2  ----->不相同<-----
               CONTENTS, ALLOC, LOAD, DATA
    2 .bss     00000f34  2000b2b0  080192f8  000232b0  2**2
               ALLOC
<
    We will fix this in two steps: first we’ll run the Keil tool called fromelf.exe
    to convert the ELF file into a .bin file that will reflect the FLASH memory 
    contents the way Keil tools expect it:
>
    fromelf.exe --bin --output <bin file> <elf file>

<    Then we will edit the .elf file using the objcopy tool to replace the data
    that gets copied to the FLASH memory with the contents of the .bin file.
    This will ensure that GDB puts the initialization data into the FLASH in
    the same way as Keil expects it:
>
    arm-eabi-objcopy.exe  --remove-section ER_RO \
    --add-section ER_RO=<bin file> \
    --set-section-flags ER_RO=CONTENTS,ALLOC,LOAD,READONLY,CODE \
    --change-section-address ER_RO=<previous address of ER_RO>\

<    The modified fragment of the Makefile will look this way
    (section names and addresses depend on the device and should
     be taken from the dump of the original elf file):
>
    ifeq ($(TARGETTYPE),APP)
    ROM_SECTION_NAME := ER_RO
    $(BINARYDIR)/$(TARGETNAME): $(all_objs) $(EXTERNAL_LIBS)
        $(LD) -o $(@:.elf=.axf) $(LDFLAGS) $(START_GROUP) $(all_objs) \
          $(LIBRARY_LDFLAGS) $(END_GROUP)
        $(FROMELF) --bin --output $(@:.elf=.bin) $(@:.elf=.axf)
        $(OBJCOPY) --remove-section $(ROM_SECTION_NAME) \
            --add-section $(ROM_SECTION_NAME)=$(@:.elf=.bin) \
            --set-section-flags \
            $(ROM_SECTION_NAME)=CONTENTS,ALLOC,LOAD,READONLY,CODE \
            --change-section-address $(ROM_SECTION_NAME)=0x08000000 \
            $(@:.elf=.axf) $@
    endif
<
    NOTE: 问题总结： ~
    根源：由于KEIL的RW的LMA未在ROM里，导致GDB的"load"命令未正确加载RW段到ROM。~
    GDB在load AXF时，会把程序load到LMA里去 (KEIL生成的AXF文件RW段的VMA和LMA相等，GCC生成的AXF文件的RW段VMA和LMA不相等). ~
    而KEIL的RW段的LMA在RAM里，所以GDB在load KEIL的AXF的时候没有load RW段到ROM里，导致KEIL的startup程序(__main)在初始化RW段时出错(KEIL默认会对数据段进行压缩处理) ~

    NOTE：解决方法总结：~
    直接把ROM里的段(ER_RO)替换成整个bin文件，于是在加载ER_RO时也同时把RW段加载了 ~

    Example: >
    #!/bin/bash
    #file: release_hs6620_rom_axf_keil2gdb.sh

    binfile='rom/out/hs6620_rom.bin'
    keilaxffile='rom/out/hs6620_rom.axf'
    gdbaxffile='rom/out/hs6620_rom_gdb.axf'
    romvectorfile='rom/out/rom_vector.bin'
    romtextfile='rom/out/rom_text.bin'

    # split the binfile to rom-vector and rom-text
    dd if=$binfile of=$romvectorfile skip=0   bs=256       iflag=skip_bytes count=1
    dd if=$binfile of=$romtextfile   skip=256 bs=100000000 iflag=skip_bytes count=1

    # relocate rom section
    arm-none-eabi-objcopy \
        --remove-section ROM_VECTOR \
        --add-section ROM_VECTOR=$romvectorfile \
        --set-section-flags ROM_VECTOR=CONTENTS,ALLOC,LOAD,READONLY,DATA \
        --change-section-address ROM_VECTOR=0x08000000 \
        $keilaxffile $gdbaxffile

    arm-none-eabi-objcopy \
        --remove-section ROM_TEXT \
        --add-section ROM_TEXT=$romtextfile \
        --set-section-flags ROM_TEXT=CONTENTS,ALLOC,LOAD,READONLY,CODE \
        --change-section-address ROM_TEXT=0x08000100 \
        $keilaxffile $gdbaxffile

    # rm tmp file
    rm -rf $romvectorfile
    rm -rf $romtextfile

8. syscalls.c >

    #include <sys/stat.h>
    #include <errno.h>
    #include <stdio.h>
    #include "hs66xx.h"

    //调用printf时候的打印输出
    static int dbg_send_bytes(const unsigned char *pdata, int len)
    {
    }

    static void dbg_flush(void)
    {
    }

    int _open (const char *name, int flags, int mode)
    {
        errno = ENOENT;
        return -1;
    }

    int _close (int file)
    {
        if (file == 1 || file == 2)
        {
            dbg_flush();
            return 0;
        }
        errno = EBADF;
        return -1;
    }

    int _isatty (int file)
    {
        if (file >= 0 && file <= 2) return 1;
        return 0;
    }

    int _read (int file, char *ptr, int len)
    {
        return 0;
    }

    int _write (int file, const char *ptr, int len)
    {
        int sent = -1;
        if (file == 1 || file == 2)
            sent = dbg_send_bytes ((const unsigned char*)ptr, len);
        return sent;
    }

    int _lseek (int file, int ptr, int dir)
    {
        return 0;
    }

    int _fstat (int file, struct stat *st)
    {
        if (file >= 0 && file <= 2)
        {
            st->st_mode = S_IFCHR;
            return 0;
        }
        errno = EBADF;
        return -1;
    }

    int _stat (char *file, struct stat *st)
    {
        errno = ENOENT;
        return -1;
    }

    //内部内存分配时候使用
    caddr_t _sbrk (int incr)
    {
        extern char _end; /* Defined by the linker */
        static char *end = &_end;
        char *prev_end = end;
        end += incr;
        return (caddr_t) prev_end;
    }

    int _fsync (int fd)
    {
        if (fd == 1 || fd == 2)
        {
            dbg_flush();
            return 0;
        }
        if (fd == 0) return 0;
        errno = EBADF;
        return -1;
    }

    void _exit (int status)
    {
        while (1);
    }

    void _abort()
    {
        while (1);
    }

    void _kill()
    {
        while (1);
    }

    pid_t _getpid (void)
    {
        return 1;
    }

9. Section: .bss VS COMMON
    在GCC里.bss和COMMON段很类似，默认情况：
    int a = 0; // place to .bss section ~
    int a;     // place to COMMON section ~

    让编译器把所有未初始化的变量放到.bss段的方式是：gcc -fno-common

    NOTE: 使用工具size时请注意：必须加入--common选项来让.bss段里包含未初始化的段，如： >
          find -name "*.o" | xargs arm-none-eabi-size --common
<    NOTE: 连接脚本里的.bss段需加入COMMON段，如： >
        .bss : {
            *(.bss*)
            *(COMMON)
            . = ALIGN(4);
            _ebss = .;
        } >ram

10. 使用Python扩展GDB:
    自定义命令的例子： >
    # 1. 导入gdb模块来访问gdb提供的python接口
    import gdb

    # 2. 用户自定义命令需要继承自gdb.Command类
    class Move(gdb.Command):

        # 3. gdb会提取该类的__doc__属性作为对应命令的文档
        """Move breakpoint
        Usage: mv old_breakpoint_num new_breakpoint
        Example:
            (gdb) mv 1 binary_search -- move breakpoint 1 to `b binary_search`
        """

        def __init__(self):
            # 4. 在构造函数中注册该命令的名字 (gdb.COMPLETE_FILENAME: 文件名字自动完成,不需要的话可以去掉)
            super(self.__class__, self).__init__("mv", gdb.COMMAND_USER, gdb.COMPLETE_FILENAME)

        # 5. 在invoke方法中实现该自定义命令具体的功能
        # args表示该命令后面所衔接的参数，这里通过string_to_argv转换成数组
        def invoke(self, args, from_tty):
            argv = gdb.string_to_argv(args)
            if len(argv) != 2:
                raise gdb.GdbError('输入参数数目不对，help mv以获得用法')
            # 6. 使用gdb.execute来执行具体的命令
            gdb.execute('delete ' + argv[0])
            gdb.execute('break ' + argv[1])

    # 7. 向gdb会话注册该自定义命令
    Move()
<
    断点的例子： >
    import gdb
    # 继承断点类
    class MyBreakpoint (gdb.Breakpoint):
        # 断点命中之后做什么
        def stop (self):
            inf_val = gdb.parse_and_eval("foo")
            if inf_val == 3:
                # 停止执行
                return True
            else:
                # 继续执行
                return False

    # 设置断点
    MyBreakpoint("source.cpp:42")
    gdb.execute("c")
<
    GDB提供的重要的API：
    1. gdb.execute(command_string, to_string=False) >
        执行GDB命令。默认输出到终端，如果to_string=True的话，输出通过返回值返回
<    2. gdb.parse_and_eval(expression_string) >
        解析表达式(函数,变量,等)，并通过返回值返回。可使用str(),int()等强制转换返回值
        获得某个函数的返回值：flash_id = int(gdb.parse_and_eval('sf_read_id(0)'))
        获得某个变量的地址: buffer_address = int(gdb.parse_and_eval('m_buffer').cast(gdb.lookup_type('int')))
        获得某个缓冲的字符串：string = gdb.parse_and_eval('FlashDevice.DevName').string()
<    3. raise gdb.GdbError(string) >
        raise 异常使用
<    4. gdb.objfiles() >
        当前调试文件,通过file命令添加的, 返回一个list
        gdb.objfiles()[0].filename: 第一个调试文件的名字

11. GNU Binary Utilities Tools:
    • ar:           Create, modify, and extract from archives
    • nm:           List symbols from object files
    • objcopy:      Copy and translate object files
    • objdump:      Display information from object files
    • ranlib:       Generate index to archive contents
    • size:         List section sizes and total size
    • strings:      List printable strings from files
    • strip:        Discard symbols
    • c++filt:      Filter to demangle encoded C++ symbols
    • cxxfilt:      MS-DOS name for c++filt
    • addr2line:    Convert addresses to file and line
    • nlmconv:      Converts object code into an NLM
    • windmc:       Generator for Windows message resources
    • windres:      Manipulate Windows resources
    • dlltool:      Create files needed to build and use DLLs
    • readelf:      Display the contents of ELF format files
    • elfedit:      Update the ELF header of ELF files

12. M0的HardFault调试小结(不带操作系统时)
    J-Link>h   #看当前处理器状态, 查堆栈指针位置 ~
      +-----------------------------------------------------------------+
      | R0 = 000002A4, R1 = 40007000, R2 = 02000000, R3 = 100003D9      |
      | R4 = 00000000, R5 = 03FFFDDF, R6 = E000ED00, R7 = E000E100      |   HardFault(IPSR)时的状态
      | R8 = FFFFFFFF, R9 = FFFFFFFF, R10= FFFFFFFF, R11= FFFFFFFF      |   主要寄存器: 
      | R12= 00000000, R13= 10007240, |MSP|= 10007240, PSP= FFFFFFFC      |-> MSP: 当前堆栈指针的位置
      | R14(LR) = 10004839, |R15(PC)| = 100000D4                          |   IPSR: 3表明在HardFault中断内
      | XPSR 61000003, APSR 60000000, EPSR 01000000, |IPSR| 00000003      |   PC
      | CFBP 00000000, |CONTROL| 00, FAULTMASK 00, BASEPRI 00, PRIMASK 00 |
      +-----------------------------------------------------------------+

    J-Link>mem32 0x10007240,40   #看堆栈 (还需要查询原始的堆栈指针的位置,即复位时候的SP值) ~
      +------------------------------------------------+
      |               |R0|       |R1|       |R2|       |R3|    |   进入HardFault前一刻的状态("一帧数据").
      | 10007240 = 00000000 FFFFFFFF E000E180 00010101 |-> 这个例子表示:在CPU执行向量号为0x13(xPSR)
      |               |R12|      |LR|   |ReturnAddr|  |xPSR|   |   的中断服务程序且在"准备"执行到地址为0x01000500
      | 10007250 = 00000000 FFFFFFF9 01000500 80000013 |   (return address)的时候,进入了HardFault.
      +------------------------------------------------+   函数调用顺序为: FFFFFFF9(中断) -> 01000500

      +------------------------------------------------+   进入中断向量号为0x13前一刻的状态("一帧数据")
      | 10007260 = 00000000 FFFFFFFF E000E180 00010101 |-> 这个例子表示: CPU"准备"执行到地址为0x10003B7E
      | 10007270 = 00000000 10003B6F 10003B7E 81000000 |   (非中断(xPSR))时进入了0x13号中断
      +------------------------------------------------+   函数调用顺序为: 10003B6F -> 10003B7E

      +------------------------------------------------+
      | 10007280 = 50000000 00000001 00000002 03FFFDDF |-> 其他一些函数调用或自动变量等产生的堆栈数据
      | 10007290 = E000E100 10000483 00000001 1000578D |
      +------------------------------------------------+

    中断进出过程(CPU自动做的): ~
        进入: 
            1. 按xPSR, return address(PC), LR, R12, R3, R2, R1, R0的顺序依次入栈(8个寄存器). 
               入栈时使用的堆栈指针取决于 *CONTROL* [1] 寄存器值, 0:MSP 1:PSP.
               嵌套中断肯定使用的是MSP.
            2. 堆栈指针更新, 使用MSP作为堆栈指针;
            3. 更新PC指针为中断相连表的指针;
            4. 更新寄存器, LR(EXE_RETURN), IPSR, NVIC寄存器;
            5. 执行中断服务程序
        退出:
            1. 加载(BX或POP)EXC_RETURN执行中断退出过程. 出栈, 根据EXC_RETURN判断使用MSP或PSP.
            2. 执行之前中断的程序


    xPSR作用: ~
        +----31----+--30--+--29---+----28----+----------+--24---+----------+----5~0-----+
        | |Negative| | |Zero| | |Carry| | |Overflow| | Reserved | |Thumb| | Reserved | |ISR_Number| |
        +----------+------+-------+----------+----------+-------+----------+------------+
        xPSR由三个寄存器组成: APSR EPSR IPSR
        ResetHandle的中断向量号(IPSR)是1, 其它的依次递增. 例如HardFault是3. ISR的起始值为16.
        中断向量号(IPSR)为0时候,表示CPU在非中断下执行

    LR(Link Register)寄存器的作用: ~
        1.  保存函数调用时候的返回地址.  ~
            BL指令会自动设置LR寄存器为函数返回地址. (函数调用前要push原始lr寄存器到堆栈)
            关于函数调用LR寄存器的使用情况的一个例子: >
            void func2(void) {
                return;
            }
            void func1(void) {
                func2();
            }
            void main(void) {
                func1();
            }
<
            main()函数的执行汇编如下: >
            +----PUSH {lr}    #保存func1执行前的lr, 即main的返回地址
            |    BL   func1   #跳转到func1, 同时设置返回地址到lr
            |+---PUSH {lr}    #保存func2执行前的lr, 即func1的返回地址
            ||+--BL   func2   #跳转到func2, 同时设置返回地址到lr
            ||+--BX   lr      #func2返回
            |+---POP  {pc}    #func1返回
            +----POP  {pc}    #main退出
<
        2.  保存中断的EXE_RETURN. ~
            进入中断时候, LR会自动被CPU赋予EXE_RETURN值.
            |EXC_RETURN|    |Condition|
            0xFFFFFFF1    Return to Handler mode (nested exception case) 嵌套中断
            0xFFFFFFF9    Return to Thread mode and use the main stack for return
            0xFFFFFFFD    Return to Thread mode and use the process stack for return

        3. 所以BX lr指令就有了两种含义(对应上面的两种): ~
            1> 跳到函数返回地址. 没啥好解释
            2> 执行中断返回过程. 因为0xFXXXXXXX地址空间是CPU的保留地址空间,
                                 所以在CPU检测到BX 0xFXXXXXXX时候会自动做出栈和堆栈指针选择等操作.
                                 中断退出过程的两个指令: BX或POP

    记住: 进入Hard Fault可能会有滞后性. ~

13. ARM thumb 指令跳转：

    指令           | 可跳转范围
    ---------------+-----------
    B (16bit,T2)   | ±2KB
    B.W (32bit,T4) | ±16MB
    BL (32bit)     | ±16MB

    所以ROM版本的芯片，ROM的基地址最好选择是0x00100000-0x00F00000，这样0地址去call RAM里的函数才能开销最小。

    以下是call开销对比（keil编译）：
        16MB之内的call开销：4bytes, 1条指令 >
                0x000045c0:    f0fbfd26    ..&.    BL       abcdefg ; 0x100010
<        16MB之外的call开销：14bytes, 4条指令 >
                0x000022a0:    f7fefd4e    ..N.    BL       $Ven$TT$L$$co_timer_set ; 0xd40
            $Ven$TT$L$$co_timer_set
                0x00000d40:    f2425c53    B.S\    MOV      r12,#0x2553
                0x00000d44:    f6c00c00    ....    MOVT     r12,#0x800
                0x00000d48:    4760        `G      BX       r12

14. GCC profiling
    -finstrument-functions
        Generate instrumentation calls for entry and exit to functions. Just after function
        entry and just before function exit, the following profiling functions are
        called with the address of the current function and its call site. >
            void __cyg_profile_func_enter (void *this_fn, void *call_site);
            void __cyg_profile_func_exit (void *this_fn, void *call_site);
<    -finstrument-functions-exclude-file-list=file,file,...
    -finstrument-functions-exclude-function-list=sym,sym,...

15. GCC ld script

    a. About LMA/VMA
        Every loadable or allocatable output section has two addresses. The first is the *VMA* , or
        virtual memory address. This is the address the section will have when the output file is
        run. The second is the *LMA* , or load memory address. This is the address at which the
        section will be loaded. In most cases the two addresses will be the same. An example of
        when they might be different is when a data section is loaded into ROM, and then copied
        into RAM when the program starts up (this technique is often used to initialize global
        variables in a ROM based system). In this case the ROM address would be the LMA, and
        the RAM address would be the VMA.
        You can see the sections in an object file by using the objdump program with the ‘-h’ option.

    b. SECTION
        基本格式：
            section_name [vma_address] [(type)] :
                [AT(lma_address)]
                [ALIGN(section_align) | ALIGN_WITH_INPUT]
                [SUBALIGN(subsection_align)]
                [constraint]
            {
                output-section-command
                output-section-command
                ...
            } [>region] [AT>lma_region] [:phdr :phdr ...] [=fillexp] [,]

    EXCLUDE_FILE

    内建命令
        ENTRY(symbol)           将符号SYMBOL的值设置成入口地址。同命令行的-e选项
        INCLUDE filename        包含其他名为filename的链接脚本 相当于c程序内的的#include指令, 用以包含另一个链接脚本.  脚本搜索路径由-L选项指定.
        INPUT(files)            将括号内的文件做为链接过程的输入文件, 命令行的-l选项一样.
        GROUP(files)            指定需要重复搜索符号定义的多个输入文件
        OUTPUT(filename)        定义输出文件的名字 同ld的-o选项
        SEARCH_DIR(path)        定义搜索路径， 同ld的-L选项, 不过由-L指定的路径要比它定义的优先被搜索。
        STARTUP(filename)       指定filename为第一个输入文件
        OUTPUT_FORMAT(bfdname)  设置输出文件使用的BFD格式 同ld选项-o format BFDNAME, 不过ld选项优先级更高.
        TARGET(bfdname)         设置输入文件的BFD格式 同ld选项-b BFDNAME.
        ASSERT(exp, message)    如果EXP不为真，终止连接过程
        FORCE_COMMON_ALLOCATION 为common symbol(通用符号)分配空间，即使用了-r连接选项也为其分配
        EXTERN(symbol symbol ...)   在输出文件中增加未定义的符号，如同连接器选项-u

    表达式
        内建函数：
            ABSOLUTE(exp)       转换成绝对值
            ADDR(section)       返回某section的VMA值。
            LOADADDR(section)   返回SECTION的LMA
            SIZEOF(section)     返回SECTION的大小。当SECTION没有被分配时，即此时SECTION的大小还不能确定时，连接器会报错。
            ALIGN(exp,align)    返回定位符'.'的修调值，对齐后的值，(. + EXP - 1) & ~(EXP - 1)
            BLOCK(exp)          如同ALIGN(EXP)，为了向前兼容。
            DEFINED(symbol)     如果符号SYMBOL在全局符号表内，且被定义了，那么返回1，否则返回0。例子，
            MAX(exp1,exp2)      返回大者
            MIN(exp1,exp2)      返回小者
            NEXT(exp)           返回下一个能被使用的地址，该地址是EXP的倍数，类似于ALIGN(EXP)。除非使用了MEMORY命令定义了一些非连续的内存块，否则NEXT(EXP)与ALIGH(EXP)一定相同。
            ORIGIN(memory)      返回memory的起始地址
            LENGTH(memory)      返回memory的长度

16. GCC优化选项
    O0: 默认选项，目的: 减少编译时间;生成可调试代码(可打断)
    O/O1: 做一些不显著增加编译时间的优化
    O2: 显著提升编译时间，提升代码性能，做不包含`space-speed tradeoff`的所有优化
    O3: 进一步优化，显著增加可执行文件大小。
    Os: 优化性能同时不增加可执行文件大小。包含O2选项中不增加代码大小的优化项
    Og: 优化性能同时不损害可调试性。包含O1选项中不损害可调试性的优化项
    Ofast: 忽视严格的标准编译性。包含O3中所有选项及` -ffast-math`

    大家对O3普遍比较谨慎，主要因为:
    - 前期Gcc版本中，O3 is buggy
    - O3往往优化后比O2还要慢一些
    第2点，主要是因为，O3在做优化时，采用了很激进的策略，例如激进的循环展开、函数内联等，
    导致生成的代码比较大，可能超出了CPU的指令Cacheinstruction cache，破坏了局部性和完整性。

    LTO（Link Time Optimization）
    链接时优化是链接期间的程序优化，多个中间文件通过链接器合并在一起，并将它们组合为一个程序，缩减代码体积，
    因此链接时优化是对整个程序的分析和跨模块的优化。link time时需要为GP alias计算大小，是否超过16bit，
    以决定用什么东西。该计算在linker中做而不是compiler来做。
    -flto是使用lto的主要方法，是一个优化选项，禁用lto使用-fno-lto。flto主要做的操作有inline、ipa(ipo)和alias分析等。

17. GCC 编译地址无关的程序
    编译选项加上：-fPIC
    >
        -fpic   Generate position-independent code (PIC) suitable for use in a shared library,
                if supported for the target machine. Such code accesses all constant addresses
                through a global offset table (GOT). The dynamic loader resolves the GOT
                entries when the program starts (the dynamic loader is not part of GCC; it
                is part of the operating system). If the GOT size for the linked executable
                exceeds a machine-specific maximum size, you get an error message from the
                linker indicating that ‘-fpic’ does not work; in that case, recompile with ‘-fPIC’
                instead. (These maximums are 8k on the SPARC, 28k on AArch64 and 32k on
                the m68k and RS/6000. The x86 has no such limit.)

                Position-independent code requires special support, and therefore works only on
                certain machines. For the x86, GCC supports PIC for System V but not for the
                Sun 386i. Code generated for the IBM RS/6000 is always position-independent.

                When this flag is set, the macros __pic__ and __PIC__ are defined to 1.

        -fPIC   If supported for the target machine, emit position-independent code, suitable
                for dynamic linking and avoiding any limit on the size of the global offset table.
                This option makes a difference on AArch64, m68k, PowerPC and SPARC.

                Position-independent code requires special support, and therefore works only
                on certain machines.

                When this flag is set, the macros __pic__ and __PIC__ are defined to 2.

        -fpie   These options are similar to ‘-fpic’ and ‘-fPIC’, but the generated position-
        -fPIE   independent code can be only linked into executables. Usually these options
                are used to compile code that will be linked using the ‘-pie’ GCC option.

                ‘-fpie’ and ‘-fPIE’ both define the macros __pie__ and __PIE__. The macros
                have the value 1 for ‘-fpie’ and 2 for ‘-fPIE’.

        -fno-plt
                Do not use the PLT for external function calls in position-independent code.
                Instead, load the callee address at call sites from the GOT and branch to it.
                This leads to more efficient code by eliminating PLT stubs and exposing GOT
                loads to optimizations. On architectures such as 32-bit x86 where PLT stubs
                expect the GOT pointer in a specific register, this gives more register allocation
                freedom to the compiler. Lazy binding requires use of the PLT; with ‘-fno-plt’
                all external symbols are resolved at load time.

                Alternatively, the function attribute noplt can be used to avoid calls through
                the PLT for specific external functions.

                In position-dependent code, a few targets also convert calls to functions that
                are marked to not use the PLT to use the GOT instead.

        -fno-jump-tables
                Do not use jump tables for switch statements even where it would be more effi-
                cient than other code generation strategies. This option is of use in conjunction
                with ‘-fpic’ or ‘-fPIC’ for building code that forms part of a dynamic linker
                and cannot reference the address of a jump table. On some targets, jump tables
                do not require a GOT and this option is not needed.

        -mbuild-constants
                Normally GCC examines a 32- or 64-bit integer constant to see if it can construct
                it from smaller constants in two or three instructions. If it cannot, it outputs
                the constant as a literal and generates code to load it from the data segment
                at run time.

                Use this option to require GCC to construct all integer constants using code,
                even if it takes more instructions (the maximum is six).

                You typically use this option to build a shared library dynamic loader. Itself a
                shared library, it must relocate itself in memory before it can find the variables
                and constants in its own data segment.

        -msingle-pic-base
                Treat the register used for PIC addressing as read-only, rather than loading
                it in the prologue for each function. The runtime system is responsible for
                initializing this register with an appropriate value before execution begins.

        -mpic-register=reg
                Specify the register to be used for PIC addressing. For standard PIC base case,
                the default is any suitable register determined by compiler. For single PIC base
                case, the default is ‘R9’ if target is EABI based or stack-checking is enabled,
                otherwise the default is ‘R10’.

        -mpic-data-is-text-relative
                Assume that the displacement between the text and data segments is fixed at
                static link time. This permits using PC-relative addressing operations to access
                data known to be in the data segment. For non-VxWorks RTP targets, this
                option is enabled by default. When disabled on such targets, it will enable
                ‘-msingle-pic-base’ by default.
<
    比如 jump label 指令
    non-PIC 的形式是：
        jump printf
        意思是调用 printf。

    PIC 的形式则是：
        jump printf-offset@GOT
        意思是跳到 GOT 表的 index 为 printf-offset 的地方处指示的地址去执行。这个地址处的代码存放在 .plt section ，
        每个外部函数对应一段这样的代码，其功能是呼叫 dynamic-loader(ld-linux.so) 来查找函数的地址(本例中是 printf)，
        然后将其地址写到 GOT 表的 index 为 printf-offset 的地方，同时执行这个函数。这样，第 2 次呼叫 printf 的时候，
        就会直接跳到 printf 的地址，而不必再查找了。

    GOT 是 data section, 是一个 table, 除专用的几个 entry，每个 entry 的内容可以在执行的时候修改；
    PLT 是 text section, 是一段一段的 code，执行中不需要修改。

    新的段 .data.rel*: 这个段的每个数据要加上PIC的基地址: >
        This may be used for read-only global variables which are initialized to something which requires a relocation,
        such as the address of a function or a different global variable. Because the global variable requires a runtime
        initialization in the form of a dynamic relocation, it can not be placed in a read-only segment. However, because
        it is declared to be constant, and therefore may not be changed by the program, the dynamic linker can mark it
        as read-only after the dynamic relocation has been applied.

        For some targets this technique may also be used for the PLT or parts of the GOT.

        Making these pages read-only helps catch some cases of memory corruption, and making the PLT in particular read-only
        helps prevent some types of buffer overflow exploits.

        The first step is in gcc. When gcc sees a variable which is constant but requires a dynamic relocation, it puts it
        into a section named .data.rel.ro (this functionality unfortunately relies on magic section names). A variable which
        requires a dynamic relocation against a local symbol is put into a .data.rel.ro.local section; this helps group such
        variables together, so that the dynamic linker may apply the relocations, which will always be RELATIVE relocations,
        more efficiently, especially when using combreloc.

        The linker groups .data.rel.ro and .data.rel.ro.local sections as usual. The new step is that the linker then emits a
        PT_GNU_RELRO program segment which covers these sections. If the PLT and/or GOT can be read-only after dynamic
        relocations, they are put next to the .data.rel.ro sections and also become part of the new segment. This segment will
        enclosed within a PT_LOAD segment. The p_vaddr field of the PT_GNU_RELRO segment gives the virtual address of the
        start of the read-only after dynamic relocations code, and the p_memsz field gives its length.

        When the dynamic linker sees a PT_GNU_RELRO segment, it uses mprotect to mark the pages as read-only after the dynamic
        relocations have been applied. Of course this only works if the segment does in fact cover an entire page. The linker
        will try to force this to happen.

        Note that the current dynamic linker code will only work correctly if the PT_GNU_RELRO segment starts on a page boundary.
        This is because the dynamic linker rounds the p_vaddr field down to the previous page boundary. If there is anything on
        the page which should not be read-only, the program is likely to fail at runtime. So in effect the linker must only emit
        a PT_GNU_RELRO segment if it ensures that it starts on a page boundary.

        I see this as a relatively minor security benefit. It is not an optimization as far as I can see. I am documenting it here
        as part of my general documentation of obscure linker features. The current description of this feature in the GNU linker
        manual is rather obscure.

18. 使用AddressSanitizer进行内存访问越界检查
    https://blog.csdn.net/c_lazy/article/details/80009627
    AddressSanitizer是google开发一个应用内存检查工具，性能据说比valgrind要好不少，可以配合clang或者GCC编译器使用，GCC需要4.8及以上版本。
    https://github.com/google/sanitizers/wiki/AddressSanitizer
    gcc -fsanitize选项真的非常强大，heap区动态申请的内存、全局data段的内存，均可以被侦测到

    使用方法
    环境：centos7.1，GCC 4.8.3
    需要安装的库：libasan.x86_64，新版本的gcc可能还需要安装libubsan，虽然说AddressSanitizer是gcc的一部分，但这两库默认是没有安装的。
    使用方法很简单，只要在编译程序时加上-fsanitize=address -fno-omit-frame-pointer两个编译选项即可，需要说明的是要使用系统自带的内存管理库，
    不能使用第三方的内存管理库，因为这个功能要拦截malloc,free等标准函数。gcc几个常用编译选项如下：
    -fsanitize=address    #开启地址越界检查功能
    -fno-omit-frame-pointer  #开启后，可以出界更详细的错误信息
    -fsanitize=leak   #开启内存泄露检查功能



vim: ft=help
