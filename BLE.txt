
1. MODE
  |-- Discoverability Modes:
  |   |---Non-discoverable               => ADV-DATA: 02 01 04 (bit0:limited, bit1:General, bit2:BR/EDR not Support)
  |   |---Limited Discoverable           => ADV-DATA: 02 01 05 (A limited period of time)
  |   `---General Discoverable           => ADV-DATA: 02 01 06
  |-- Connectability Modes
  |   |---Non-connectable
  |   |   |-- Scannable Undirected       => ADV-PARAM: ADV_SCAN_IND (Should set SCAN_RSP_DATA)
  |   |   |-- Non-connectable Undirected => ADV-PARAM: ADV_NONCONN_IND
  |   `---Connectable
  |       |-- Connectable Undirected     => ADV-PARAM: ADV_IND
  |       `-- Connectable Directed       => ADV-PARAM: ADV_DIRECT_IND
  `-- Bondable Modes
      |-- Non-bondable Mode              => Not accept a pairing request
      `-- Bondable Mode                  => Accept a pairing request


2. When adv is ADV_SCAN_IND & ADV_NONCONN_IND, the adv interval must bigger than 160 (100ms)

3. 单位
    625us : scan_interval
            scan_window
            adv_interval (>=32*625us)
    1.25ms: connection_interval
            WinSize
            WinOffset
    10ms  : connection_supperv_timeout

4. BLE带宽是1MHZ,所以传输1bit耗时1us,1byte耗时8us.
    一个空中数据包的最大长度是47byte, 于是一次BLE通信需要：2 * (47 * 8 + 150) - 150 = (1052-150)us, N次需要 N*1052-150 us

5. SMP Key管理:
    第一种管理方法: 保存所有Key: LTK, IRK, CSRK
        ==> LE_Long_Term_Key_Request_Event: <Rand>, <EDIV>
        <== LE_Long_Term_Key_Request_Reply_Command: *LTK*

    第二种管理方法: 仅仅保存 |ER| 和 |IR|
        LTK, IRK, CSRK 产生过程:
        ==> LE_Long_Term_Key_Request_Event: <Rand>, <EDIV>
            DHK = d1(|IR|, 3, 0);
            Y = dm(DHK, <Rand>);
            DIV = Y xor <EDIV>;
            *LTK* = d1(|ER|, DIV, 0);
            *CSRK* = d1(|ER|, DIV, 1);
            *IRK* = d1(|IR|, 1, 0);
        <== LE_Long_Term_Key_Request_Reply_Command: *LTK*
        note: d1和dm方法都需要AES128加密算法

    <DIV> 和 <Rand> 其实都是随机数，且这个随机数都可以从controller获取

    下次重新链接使用配对过程中Slave分发的Key来进行链路加密
    Master应该存储slave的 LTK, CSRK, IRK, RAND, EDIV, 以备下次链接时候使用。
    Slave可以存储Master的Keys，如果以后有机会翻转角色

6. SMP常规加密链路过程（配对之后，重连）：
    Master, host -> controller ~
    |LE_Start_Encryption_Command|: con_handle, <Rand>, <EDIV>, *LTK*
    Note：这个命令只有Master有, 且 <Rand><EDIV> 发送给Slave, *LTK* Master自己用

    mater-controller -> slave-controller ~
    |LL_ENC_REQ|: <Rand>, <EDIV>, <SKDm>, <IVm>
    Note: 这个命令只能Master发送

    slave-controller -> master-controller ~
    |LL_ENC_RSP|: <SKDs>, <IVs>

    Slave, controller -> host ~
    |LE_Long_Term_Key_Request_Event|: con_handle <Rand>, <EDIV>
    Note: 这个命令只有Slave有

    Slave, host -> controller ~
    |LE_Long_Term_Key_Request_Reply_Command|: con_handle, *LTK*
    Note: *LTK* 可以是Slave本地存储的也可以是使用ER,IR,Rand,EDIV算出来的，且LTK应该和Master的相同

    slave-controller -> master-controller ~
    |LL_START_ENC_REQ|, No Encrypt MIC
    Note: 这个命令只能Slave发送

    master-controller -> slave-controller ~
    |LL_START_ENC_RSP|, With Encrypt MIC
    Note: link Encrypt Begin

    slave-controller -> master-controller ~
    |LL_START_ENC_RSP|, With Encrypt MIC

7. att，当比较16bit的UUID和128bit时，需要转换16bit到128bit，然后再比较

8. MTU:
    LL_ MTU:   max47(data39) (Fix)
    L2CAP_MTU: min48(ACL-U) min23(LE-U) (Change: CONFIGURATION REQUEST, L2CAP)
    ATT_MTU:   min48(BR/EDR) min23(LE) (Change: Attribute Protocol Exchange MTU Request , ATT)
    HCI ACL:   min27

9. 关于l2cap拆包组包: 
    ACL Data Packets, l2cap的Packet_Boundary_Flag表示start包或continue包，并发送或接收这个信息通过HCI。
    LL接收或者发送这个信息。空中数据传输，使用LLID标识当前包是start包后continue包。

10. SMP.
    经典蓝牙使用了椭圆曲线加密技术(ECC，elliptic curve cryptography and Diffie-Hellman)，该技术可以防止窃听，但是当前版本的BLE(4.0,4.1)
    没有使用该技术，所以BLE无法阻止配对过程的窃听行为。但是未来版本的BLE中可能会加入ECC。

    None of the pairing methods provide protection against a passive eavesdropper during the pairing 
    process as predictable or easily established values for TK are used. If the pairing information 
    is distributed without an eavesdropper being present then all the pairing methods provide confidentiality.
    Note: A future version of this specification will include elliptic curve cryptography and 
    Diffie-Hellman public key exchanges that will provide passive eavesdropper protection.

    现行的公钥加密技术：
        椭圆曲线加密技术 (ECC) 是一种基于椭圆曲线的代数在有限域上的公共密钥加密技术。 
        基于因数分解问题的因数分解密码系统，典型代表为RSA；
        基于离散对数问题的离散对数密码系统，典型代表为DSA;
        基于椭圆曲线离散对数问题的椭圆曲线密码系统（ECC）;

11. OOB (out of band)
    Out of Band An out of band mechanism may be used to communicate information to help with device discovery,
    for example device address, and the 128-bit TK value used in the pairing process.
    OOB Data Block Format: Core_4.1.pdf-P1960
    Rules for using Out-of-Band and MITM flags: Core_4.1.pdf-P2253

12. Acknowledgement and Flow Control
    进入连接状态SN, NESN都设置成0 ~

    任何一方的连续两次的SN,NESN一一相同时，则第二包肯定是它的重传包并且要求对方重传。~

    空中NESN&SN重复过程及发送者意愿: ~
      +---------+       +-----------------------------------+
      | NESN SN |       | 发送者意愿:                       |
      |         |       |                                   |
      |  0   0  |       | SN                                |
      |    X    |       | \:相同 √ 发送者是发送的新数据     |
      |  1   0  |  ==>  | \:相反 x 发送者是重发的旧数据     |
      |    X    |       |                                   |
      |  1   1  |       | NESN                              |
      |    X    |       | /:相同 x nack 要求对方重发旧数据  |
      |  0   1  |       | /:相反 √ ack  要求对方发送新数据  |
      +---------+       +-----------------------------------+

    接收到了一个数据通道的数据包时候，应该按如下判断：~
           +-----------------------+               +-----------------------+
           | local_sn == rx_nesn ? |               | local_nesn == rx_sn ? |
           +-----+------------+----+               +----+--------------+---+
                 |different   |same                     |same          |different
                 |(ack)       |(nack)                   |(new data)    |(old data)
    +------------V-----+ +----V-----------+  +----------V-----+ +------V---------+
    | local_sn=rx_nesn | |                |  | Inc local_nesn | |                |
    | TX NEW DATA      | | RE-TX OLD DATA |  | RX NEW DATA    | | Ignore RX DATA |
    +------------------+ +----------------+  +----------------+ +----------------+

13. HCI, BLE only 时候支持的HCI与所有HCI的对比

    //#define HCI_INQUIRY                                     (0x0001 + LC_G)
    //#define HCI_INQUIRY_CANCEL                              (0x0002 + LC_G)
    //#define HCI_PERIODIC_INQUIRY_MODE                       (0x0003 + LC_G)
    //#define HCI_EXIT_PERIODIC_INQUIRY_MODE                  (0x0004 + LC_G)
    //#define HCI_CREATE_CONNECTION                           (0x0005 + LC_G)
    #define HCI_DISCONNECT                                  (0x0006 + LC_G) ~
    //#define HCI_ADD_SCO_CONNECTION                          (0x0007 + LC_G)
    //#define HCI_CREATE_CONNECTION_CANCEL                    (0x0008 + LC_G)
    //#define HCI_ACCEPT_CONNECTION_REQUEST                   (0x0009 + LC_G)
    //#define HCI_REJECT_CONNECTION_REQUEST                   (0x000A + LC_G)
    //#define HCI_LINK_KEY_REQUEST_REPLY                      (0x000B + LC_G)
    //#define HCI_LINK_KEY_REQUEST_NEGATIVE_REPLY             (0x000C + LC_G)
    //#define HCI_PIN_CODE_REQUEST_REPLY                      (0x000D + LC_G)
    //#define HCI_PIN_CODE_REQUEST_NEGATIVE_REPLY             (0x000E + LC_G)

    //#define HCI_CHANGE_CONNECTION_PACKET_TYPE               (0x000F + LC_G)
    //#define HCI_AUTHENTICATION_REQUESTED                    (0x0011 + LC_G)
    //#define HCI_SET_CONNECTION_ENCRYPTION_ENABLE            (0x0013 + LC_G)
    //#define HCI_CHANGE_CONNECTION_LINK_KEY                  (0x0015 + LC_G)
    //#define HCI_MASTER_LINK_KEY                             (0x0017 + LC_G)
    //#define HCI_REMOTE_NAME_REQUEST                         (0x0019 + LC_G)
    //#define HCI_REMOTE_NAME_REQUEST_CANCEL                  (0x001A + LC_G)
    //#define HCI_READ_REMOTE_FEATURES                        (0x001B + LC_G)
    //#define HCI_READ_REMOTE_EXTENDED_FEATURES               (0x001C + LC_G)
    #define HCI_READ_REMOTE_VER_INFO                        (0x001D + LC_G) ~
    //#define HCI_READ_CLOCK_OFFSET                           (0x001F + LC_G)

    //#define HCI_READ_LMP_HANDLE                             (0x0020 + LC_G)
    //#define HCI_EXCHANGE_FIXED_INFO                         (0x0021 + LC_G)
    //#define HCI_EXCHANGE_ALIAS_INFO                         (0x0022 + LC_G)
    //#define HCI_PRIVATE_PAIRING_REQUEST_REPLY               (0x0023 + LC_G)
    //#define HCI_PRIVATE_PAIRING_REQUEST_NEGATIVE_REPLY      (0x0024 + LC_G)
    //#define HCI_GENERATED_ALIAS                             (0x0025 + LC_G)
    //#define HCI_ALIAS_ADDRESS_REQUEST_REPLY                 (0x0026 + LC_G)
    //#define HCI_ALIAS_ADDRESS_REQUEST_NEGATIVE_REPLY        (0x0027 + LC_G)
    //#define HCI_SETUP_SYNCHRONOUS_CONNECTION                (0x0028 + LC_G)
    //#define HCI_ACCEPT_SYNCHRONOUS_CONNECTION_REQUEST       (0x0029 + LC_G)
    //#define HCI_REJECT_SYNCHRONOUS_CONNECTION_REQUEST       (0x002A + LC_G)

    //#define HCI_IO_CAPABILITY_REQUEST_REPLY                 (0x002B + LC_G)
    //#define HCI_USER_CONFIRMATION_REQUEST_REPLY             (0x002C + LC_G)
    //#define HCI_USER_CONFIRMATION_REQUEST_NEGATIVE_REPLY    (0x002D + LC_G)
    //#define HCI_USER_PASSKEY_REQUEST_REPLY                  (0x002E + LC_G)
    //#define HCI_USER_PASSKEY_REQUEST_NEGATIVE_REPLY         (0x002F + LC_G)
    //#define HCI_REMOTE_OOB_DATA_REQUEST_REPLY               (0x0030 + LC_G)
    //#define HCI_REMOTE_OOB_DATA_REQUEST_NEGATIVE_REPLY      (0x0033 + LC_G)
    //#define HCI_IO_CAPABILITY_REQUEST_NEGATIVE_REPLY        (0x0034 + LC_G)

    //#define HCI_HOLD_MODE                                   (0x0001 + LP_G)
    //#define HCI_SNIFF_MODE                                  (0x0003 + LP_G)
    //#define HCI_EXIT_SNIFF_MODE                             (0x0004 + LP_G)
    //#define HCI_PARK_MODE                                   (0x0005 + LP_G)
    //#define HCI_EXIT_PARK_MODE                              (0x0006 + LP_G)
    //#define HCI_QOS_SETUP                                   (0x0007 + LP_G)
    //#define HCI_ROLE_DISCOVERY                              (0x0009 + LP_G)
    //#define HCI_SWITCH_ROLE                                 (0x000B + LP_G)
    //#define HCI_READ_LINK_POLICY_SETTINGS                   (0x000C + LP_G)
    //#define HCI_WRITE_LINK_POLICY_SETTINGS                  (0x000D + LP_G)
    //#define HCI_READ_DEFAULT_LINK_POLICY_SETTINGS           (0x000E + LP_G)
    //#define HCI_WRITE_DEFAULT_LINK_POLICY_SETTINGS          (0x000F + LP_G)
    //#define HCI_FLOW_SPECIFICATION                          (0x0010 + LP_G)
    //#define HCI_SNIFF_SUBRATING                             (0x0011 + LP_G)

    #define HCI_SET_EVENT_MASK                              (0x0001 + HC_G) ~
    #define HCI_RESET                                       (0x0003 + HC_G) ~
    //#define HCI_SET_EVENT_FILTER                            (0x0005 + HC_G)
    #define HCI_FLUSH                                       (0x0008 + HC_G) ~
    //#define HCI_READ_PIN_TYPE                               (0x0009 + HC_G)
    //#define HCI_WRITE_PIN_TYPE                              (0x000A + HC_G)
    //#define HCI_CREATE_NEW_UNIT_KEY                         (0x000B + HC_G)
    //#define HCI_READ_STORED_LINK_KEY                        (0x000D + HC_G)
    //#define HCI_WRITE_STORED_LINK_KEY                       (0x0011 + HC_G)
    //#define HCI_DELETE_STORED_LINK_KEY                      (0x0012 + HC_G)
    //#define HCI_CHANGE_LOCAL_NAME                           (0x0013 + HC_G)
    //#define HCI_READ_LOCAL_NAME                             (0x0014 + HC_G)
    //#define HCI_READ_CONNECT_ACCEPT_TO                      (0x0015 + HC_G)
    //#define HCI_WRITE_CONNECT_ACCEPT_TO                     (0x0016 + HC_G)
    //#define HCI_READ_PAGE_TIMEOUT                           (0x0017 + HC_G)
    //#define HCI_WRITE_PAGE_TIMEOUT                          (0x0018 + HC_G)
    //#define HCI_READ_SCAN_ENABLE                            (0x0019 + HC_G)
    //#define HCI_WRITE_SCAN_ENABLE                           (0x001A + HC_G)

    //#define HCI_READ_PAGE_SCAN_ACT                          (0x001B + HC_G)
    //#define HCI_WRITE_PAGE_SCAN_ACT                         (0x001C + HC_G)
    //#define HCI_READ_INQUIRY_SCAN_ACT                       (0x001D + HC_G)
    //#define HCI_WRITE_INQUIRY_SCAN_ACT                      (0x001E + HC_G)
    //#define HCI_READ_AUTHENTICATION_ENABLE                  (0x001F + HC_G)
    //#define HCI_WRITE_AUTHENTICATION_ENABLE                 (0x0020 + HC_G)
    //#define HCI_READ_ENCRYPTION_MODE                        (0x0021 + HC_G)
    //#define HCI_WRITE_ENCRYPTION_MODE                       (0x0022 + HC_G)
    //#define HCI_READ_CLASS_OF_DEVICE                        (0x0023 + HC_G)
    //#define HCI_WRITE_CLASS_OF_DEVICE                       (0x0024 + HC_G)
    //#define HCI_READ_VOICE_SETTINGS                         (0x0025 + HC_G)
    //#define HCI_WRITE_VOICE_SETTINGS                        (0x0026 + HC_G)
    //#define HCI_READ_AUTOMATIC_FLUSH_TIMEOUT                (0x0027 + HC_G)
    //#define HCI_WRITE_AUTOMATIC_FLUSH_TIMEOUT               (0x0028 + HC_G)
    //#define HCI_READ_NUM_BROADCAST_RETRANSMISSIONS          (0x0029 + HC_G)
    //#define HCI_WRITE_NUM_BROADCAST_RETRANSMISSIONS         (0x002A + HC_G)
    //#define HCI_READ_HOLD_MODE_ACTIVITY                     (0x002B + HC_G)
    //#define HCI_WRITE_HOLD_MODE_ACTIVITY                    (0x002C + HC_G)
    #define HCI_READ_TRANSMIT_POWER_LEVEL                   (0x002D + HC_G) ~
    //#define HCI_READ_SYNCHRONOUS_FLOW_CONTROL_ENABLE        (0x002E + HC_G)
    //#define HCI_WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE       (0x002F + HC_G)
    #define HCI_SET_HOST_CONTROLLER_TO_HOST_FLOW_CONTROL    (0x0031 + HC_G) ~
    #define HCI_HOST_BUFFER_SIZE                            (0x0033 + HC_G) ~
    #define HCI_HOST_NUMBER_OF_COMPLETED_PACKETS            (0x0035 + HC_G) ~
    //#define HCI_READ_SUPERVISION_TIMEOUT                    (0x0036 + HC_G)
    //#define HCI_WRITE_SUPERVISION_TIMEOUT                   (0x0037 + HC_G)
    //#define HCI_READ_NUMBER_OF_SUPPORTED_IAC                (0x0038 + HC_G)
    //#define HCI_READ_CURRENT_IAC_LAP                        (0x0039 + HC_G)
    //#define HCI_WRITE_CURRENT_IAC_LAP                       (0x003A + HC_G)
    //#define HCI_READ_PAGE_SCAN_PERIOD_MODE                  (0x003B + HC_G)
    //#define HCI_WRITE_PAGE_SCAN_PERIOD_MODE                 (0x003C + HC_G)
    //#define HCI_READ_PAGE_SCAN_MODE                         (0x003D + HC_G)
    //#define HCI_WRITE_PAGE_SCAN_MODE                        (0x003E + HC_G)

    //#define HCI_SET_AFH_HOST_CHANNEL_CLASSIFICATION         (0x003F + HC_G)

    //#define HCI_READ_INQUIRY_SCAN_TYPE                      (0x0042 + HC_G)
    //#define HCI_WRITE_INQUIRY_SCAN_TYPE                     (0x0043 + HC_G)
    //#define HCI_READ_INQUIRY_MODE                           (0x0044 + HC_G)
    //#define HCI_WRITE_INQUIRY_MODE                          (0x0045 + HC_G)
    //#define HCI_READ_PAGE_SCAN_TYPE                         (0x0046 + HC_G)
    //#define HCI_WRITE_PAGE_SCAN_TYPE                        (0x0047 + HC_G)
    //#define HCI_READ_AFH_CHANNEL_ASSESSMENT_MODE            (0x0048 + HC_G)
    //#define HCI_WRITE_AFH_CHANNEL_ASSESSMENT_MODE           (0x0049 + HC_G)
    //#define HCI_RESET_FIXED_ADDRESS_ATTEMPTS_COUNTER        (0x0050 + HC_G)
    //#define HCI_READ_EXTENDED_INQUIRY_RESPONSE_COMMAND      (0x0051 + HC_G)
    //#define HCI_WRITE_EXTENDED_INQUIRY_RESPONSE_COMMAND     (0x0052 + HC_G)
    //#define HCI_REFRESH_ENCRYPTION_KEY                        (0x0053 + HC_G)
    //#define HCI_READ_SIMPLE_PAIRING_MODE                    (0x0055 + HC_G)
    //#define HCI_WRITE_SIMPLE_PAIRING_MODE                   (0x0056 + HC_G)
    //#define HCI_READ_LOCAL_OOB_DATA                         (0x0057 + HC_G)
    //#define HCI_READ_INQUIRY_RESPONSE_TRANSMIT_POWER_LEVEL  (0x0058 + HC_G)
    //#define HCI_WRITE_INQUIRY_TRANSMIT_POWER_LEVEL          (0x0059 + HC_G)
    //#define HCI_READ_DEFAULT_ERRONEOUS_DATA_REPORTING       (0x005A + HC_G)
    //#define HCI_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING      (0x005B + HC_G)
    //#define HCI_ENHANCED_FLUSH                              (0x005F + HC_G)
    //#define HCI_SEND_KEYPRESS_NOTIFICATION                  (0x0060 + HC_G)
    //#define HCI_READ_ENHANCED_TRANSMIT_POWER_LEVEL          (0X0068 + HC_G)

    #define HCI_READ_LE_HOST_SUPPORT                        (0X006C + HC_G) ~
    #define HCI_WRITE_LE_HOST_SUPPORT                       (0X006D + HC_G) ~

    //#define HCI_READ_AUTHENTICATED_PAYLOAD_TIMEOUT          (0x007B + HC_G)
    //#define HCI_WRITE_AUTHENTICATED_PAYLOAD_TIMEOUT         (0x007C + HC_G)

    #define HCI_READ_LOCAL_VER_INFO                         (0x0001 + HI_G) ~
    #define HCI_READ_LOCAL_COMMANDS                         (0x0002 + HI_G) ~
    #define HCI_READ_LOCAL_FEATURES                         (0x0003 + HI_G) ~
    //#define HCI_READ_LOCAL_EXTENDED_FEATURES                (0x0004 + HI_G)
    #define HCI_READ_BUFFER_SIZE                            (0x0005 + HI_G) ~
    //#define HCI_READ_COUNTRY_CODE                           (0x0007 + HI_G)
    #define HCI_READ_BD_ADDR                                (0x0009 + HI_G) ~

    //#define HCI_READ_FAILED_CONTACT_COUNTER                 (0x0001 + HS_G)
    //#define HCI_RESET_FAILED_CONTACT_COUNTER                (0x0002 + HS_G)
    //#define HCI_GET_LINK_QUALITY                            (0x0003 + HS_G)
    #define HCI_READ_RSSI                                   (0x0005 + HS_G) ~
    //#define HCI_READ_AFH_CHANNEL_MAP                        (0x0006 + HS_G)
    //#define HCI_READ_CLOCK                                  (0x0007 + HS_G)
    //#define HCI_READ_ENCRYPTION_KEY_SIZE                    (0x0008 + HS_G)

    //#define HCI_READ_LOOPBACK_MODE                          (0x0001 + HT_G)
    //#define HCI_WRITE_LOOPBACK_MODE                         (0x0002 + HT_G)
    //#define HCI_ENABLE_DEVICE_UNDER_TEST_MODE               (0x0003 + HT_G)
    //#define HCI_WRITE_SIMPLE_PAIRING_DEBUG_MODE             (0x0004 + HT_G)


    #define HCI_LE_SET_EVENT_MASK                          (0x0001 + LE_G) ~
    #define HCI_LE_READ_BUFFER_SIZE                        (0x0002 + LE_G) ~
    #define HCI_LE_READ_LOCAL_SUPPORTED_FEATURES           (0x0003 + LE_G) ~
    #define HCI_LE_SET_RANDOM_ADDRESS                      (0x0005 + LE_G) ~
    #define HCI_LE_SET_ADVERTISING_PARAMETERS              (0x0006 + LE_G) ~
    #define HCI_LE_READ_ADVERTISING_CHANNEL_TX_POWER       (0x0007 + LE_G) ~
    #define HCI_LE_SET_ADVERTISING_DATA                    (0x0008 + LE_G) ~
    #define HCI_LE_SET_SCAN_RESPONSE_DATA                  (0x0009 + LE_G) ~
    #define HCI_LE_SET_ADVERTISE_ENABLE                    (0x000A + LE_G) ~
    #define HCI_LE_SET_SCAN_PARAMETERS                     (0x000B + LE_G) ~
    #define HCI_LE_SET_SCAN_ENABLE                         (0x000C + LE_G) ~
    #define HCI_LE_CREATE_CONNECTION                       (0x000D + LE_G) ~
    #define HCI_LE_CREATE_CONNECTION_CANCEL                (0x000E + LE_G) ~
    #define HCI_LE_READ_WHITE_LIST_SIZE                    (0x000F + LE_G) ~
    #define HCI_LE_CLEAR_WHITE_LIST                        (0x0010 + LE_G) ~
    #define HCI_LE_ADD_DEVICE_TO_WHITE_LIST                (0x0011 + LE_G) ~
    #define HCI_LE_REMOVE_DEVICE_FROM_WHITE_LIST           (0x0012 + LE_G) ~
    #define HCI_LE_CONNECTION_UPDATE                       (0x0013 + LE_G) ~
    #define HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION         (0x0014 + LE_G) ~
    #define HCI_LE_READ_CHANNEL_MAP                        (0x0015 + LE_G) ~
    #define HCI_LE_READ_REMOTE_USED_FEATURES               (0x0016 + LE_G) ~
    #define HCI_LE_ENCRYPT                                 (0x0017 + LE_G) ~
    #define HCI_LE_RAND                                    (0x0018 + LE_G) ~
    #define HCI_LE_START_ENCRYPTION                        (0x0019 + LE_G) ~
    #define HCI_LE_LONG_TERM_KEY_REQUEST_REPLY             (0x001A + LE_G) ~
    #define HCI_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY    (0x001B + LE_G) ~
    #define HCI_LE_READ_SUPPORTED_STATES                   (0x001C + LE_G) ~
    #define HCI_LE_RECEIVER_TEST                           (0x001D + LE_G) ~
    #define HCI_LE_TRANSMITTER_TEST                        (0x001E + LE_G) ~
    #define HCI_LE_TEST_END                                (0x001F + LE_G) ~
    #define HCI_LE_REMOTE_CONNECTION_PARAM_REQUEST_REPLY   (0x0020 + LE_G) ~
    #define HCI_LE_REMOTE_CONNECTION_PARAM_REQUEST_NEGATIVE_REPLY  (0x0021 + LE_G) ~
    #define MAX_HC_LE_COMMAND_OPCODE                       0x21 ~

    //#define HCI_INQUIRY_COMPLETE_EVENT                         0x01
    //#define HCI_INQUIRY_RESULT_EVENT                           0x02
    //#define HCI_CONNECTION_COMPLETE_EVENT                      0x03
    //#define HCI_CONNECTION_REQUEST_EVENT                       0x04
    #define HCI_DISCONNECTION_COMPLETE_EVENT                   0x05 ~
    //#define HCI_AUTHENTICATION_COMPLETE_EVENT                  0x06
    //#define HCI_READ_REMOTE_NAME_REQUEST_COMPLETE_EVENT        0x07
    #define HCI_ENCRYPTION_CHANGE_EVENT                        0x08 ~
    //#define HCI_CHANGE_CONNECTION_LINK_KEY_COMPLETE_EVENT      0x09
    //#define HCI_MASTER_LINK_KEY_COMPLETE_EVENT                 0x0A
    //#define HCI_READ_REMOTE_SUPPORTED_FEATURES_COMPLETE_EVENT  0x0B
    #define HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT 0x0C ~
    //#define HCI_QoS_SETUP_COMPLETE_EVENT                       0x0D
    #define HCI_COMMAND_COMPLETE_EVENT                         0x0E ~
    #define HCI_COMMAND_STATUS_EVENT                           0x0F ~
    #define HCI_HARDWARE_ERROR_EVENT                           0x10 ~
    #define HCI_FLUSH_OCCURED_EVENT                            0x11 ~
    #define HCI_ROLE_CHANGE_EVENT                              0x12 ~
    #define HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT              0x13 ~
    //#define HCI_MODE_CHANGE_EVENT                              0x14
    //#define HCI_RETURN_LINK_KEYS_EVENT                         0x15
    //#define HCI_PIN_CODE_REQUEST_EVENT                         0x16
    //#define HCI_LINK_KEY_REQUEST_EVENT                         0x17
    //#define HCI_LINK_KEY_NOTIFICATION_EVENT                    0x18
    //#define HCI_LOOPBACK_COMMAND_EVENT                         0x19
    #define HCI_DATA_BUFFER_OVERFLOW_EVENT                     0x1A ~
    //#define HCI_MAX_SLOTS_CHANGE_EVENT                         0x1B
    //#define HCI_READ_CLOCK_OFFSET_EVENT                        0x1C
    //#define HCI_CONNECTION_PACKET_TYPE_CHANGED_EVENT           0x1D
    //#define HCI_CONNECTION_PACKET_TYPE_CHANGED_EVENT           0x1D
    //#define HCI_QOS_VIOLATION_EVENT                            0x1E
    //#define HCI_PAGE_SCAN_MODE_CHANGE_EVENT                    0x1F
    //#define HCI_PAGE_SCAN_REPETITION_MODE_CHANGE_EVENT         0x20

    //#define HCI_FLOW_SPECIFICATION_COMPLETE_EVENT              0x21
    //#define HCI_INQUIRY_RESULT_EVENT_WITH_RSSI                 0x22
    //#define HCI_READ_REMOTE_EXTENDED_FEATURES_COMPLETE_EVENT   0x23

    //#define HCI_DEBUG_EVENT                                    0x24

    //#define HCI_ALIAS_ADDRESS_EVENT                            0x25
    //#define HCI_ACTIVE_ADDRESS_EVENT                           0x27
    //#define HCI_SYNCHRONOUS_CONNECTION_COMPLETE_EVENT          0x2C
    //#define HCI_SYNCHRONOUS_CONNECTION_CHANGED_EVENT           0x2D
    //#define HCI_SNIFF_SUBRATING_EVENT                          0x2E
    //#define HCI_EXTENDED_INQUIRY_RESULT_EVENT                  0x2F
    #define HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT          0x30 ~
    //#define HCI_ALIAS_NOT_RECOGNIZED_EVENT                      TBD
    //#define HCI_FIXED_ADDRESS_ATTEMPT_EVENT                     TBD

    //#define HCI_IO_CAPABILITY_REQUEST_EVENT                    0x31
    //#define HCI_IO_CAPABILITY_RESPONSE_EVENT                   0x32
    //#define HCI_USER_CONFIRMATION_REQUEST_EVENT                0x33
    //#define HCI_USER_PASSKEY_REQUEST_EVENT                     0x34
    //#define HCI_REMOTE_OOB_DATA_REQUEST_EVENT                  0x35
    //#define HCI_SIMPLE_PAIRING_COMPLETE_EVENT                  0x36

    //#define HCI_LINK_SUPERVISION_TIMEOUT_CHANGED_EVENT         0x38
    //#define HCI_ENHANCED_FLUSH_COMPLETE_EVENT                  0x39
    //#define HCI_USER_PASSKEY_NOTIFICATION_EVENT                0x3B
    //#define HCI_KEYPRESS_NOTIFICATION_EVENT                    0x3C
    //#define HCI_REMOTE_HOST_SUPPORTED_FEATURES_NOTIFICATION_EVENT 0x3D
    //#define HCI_AUTHENTICATION_PAYLOAD_TIMEOUT_EXCEEDED        0x57
    #define HCI_LE_EVENT                                       0x3E ~

    #define LE_SUBEVENT_CONNECTION_COMPLETE                    0x01 ~
    #define LE_SUBEVENT_ADVERTISING_REPORT                     0x02 ~
    #define LE_SUBEVENT_CONNECTION_UPDATE_COMPLETE             0x03 ~
    #define LE_SUBEVENT_READ_REMOTE_USED_FEATURES_COMPLETE     0x04 ~
    #define LE_SUBEVENT_LONG_TERM_KEY_REQUEST                  0x05 ~
    #define LE_SUBEVENT_REMOTE_CONNECTION_PARAMETER_REQUEST    0x06 ~

    //#define SMP_USER_PASSKEY_NOTIFICATION_EVENT                0x21
    //#define SMP_USER_PASSKEY_REQUEST_EVENT                     0x22
    //#define SMP_USER_OOB_DATA_REQUEST_EVENT                    0x23
    //#define SMP_PAIRING_COMPLETE_EVENT                         0x24
    //#define SMP_PAIRING_REQUEST_EVENT                          0x25
    //#define SMP_SECURITY_REQUEST_EVENT                         0x26

    //#define GATT_COMMAND_COMPLETE_EVENT                        0x41
    //#define GATT_DISCOVER_SERVICES_EVENT                       0x42
    //#define GATT_DISCOVER_SERVICES_BY_UUID_EVENT               0x43
    //#define GATT_DISCOVER_CHARACTERISTICS_EVENT                0x44
    //#define GATT_DISCOVER_DESCRIPTORS_EVENT                    0x45
    //#define GATT_READ_RESPONSE_EVENT                           0x46
    //#define GATT_READ_BY_TYPE_RESPONSE_EVENT                   0x47
    //#define GATT_DISCOVER_INCLUDED_SERVICES_EVENT              0x48
    //#define GATT_MAX_MTU_EVENT                                 0x49
    //#define GATT_RELIABLE_WRITE_COMPLETE_EVENT                 0x4A  - Deprecated
    //#define GATT_WRITE_COMPLETE_EVENT                          0x4B
    //#define GATT_READ_LONG_RESPONSE_EVENT                      0x4C
    //#define GATT_WRITE_RESPONSE_EVENT                          0x4D  - Deprecated
    //#define GATT_VALUE_NOTIFICATION_EVENT                      0x4E
    //#define GATT_VALUE_INDICATION_EVENT                        0x4F
    //#define GATT_VALUE_CONFIRMATION_EVENT                      0x50
    //#define GATT_WRITE_INDICATION_EVENT                        0x51

    //#define L2CAP_CONNECTION_UPDATE_RESPONSE_EVENT             0x61

    //#define HCI_LE_APP_EVENT                                   0x71

    //#define GAP_CONNECTION_COMPLETE_EVENT                      0x81

14. BLE 初始化流程 (ref: core_4.1.pdf, Vol2-PartE)
    1 7.3.2 => Reset (Must)
    2 7.4.1 => Read Local Version Infomation (option) 
    3 7.4.2 => Read Local Supported Commands (option)
    4 7.4.6 => Read BD_ADDR Command
    5 7.3.1 => Set Event Mask Command (option) (0x3FFFFFFFFFFFFFFF)
    6 7.8.1 => LE Set Event Mask (option) (0x000000000000001F, config)
    7 7.4.5 => Read Buffer Size Command
    8 7.8.2 => LE Read Buffer Size (Must) 
    9 7.8.3 => LE Read Local Support Features (option)

15. Filter Policy (White List)
    a. Advertiser: (Config: LE_SET_ADVERTISING_PARAMETERS_COMMAND) ~
        - Accept all;
        - Accept SCAN_REQ from wlist;
        - Accept CONNECT_REQ from wlist;
        - Accept SCAN_REQ & CONNECT_REQ from wlist;

    b. Scanner: (Config: LE_SET_SCAN_PARAMETERS_COMMAND) ~
        - Accept all (Except ADV_DIRECT_IND's InitA&RxAdd not match Scanner own address);
        - Accept from wlists (Except ADV_DIRECT_IND's InitA&RxAdd not match Scanner own address);
        + Accept all (If ADV_DIRECT_IND's InitA&RxAdd is RPA, Resolve it);
        + Accept from wlists (If ADV_DIRECT_IND's InitA&RxAdd is RPA, Resolve it);

    c. Initiator: (Config: LE_CREATE_CONNECTION_COMMAND) ~
        - Accept host assign (Except ADV_DIRECT_IND's InitA&RxAdd not match Initiator own address);
        - Accept from wlist (Except ADV_DIRECT_IND's InitA&RxAdd not match Initiator own address);

16. Privacy (RPA, Resolving List)
    Config: LE_SET_ADDRESS_RESOLUTION_ENABLE_COMMAND
    以下均为Privacy打开的情况。

    接收者地址解析过程如下:

    |Advertiser|
        TX: ADV_IND: AdvA={Non-RPA|RPA=[Host(NoLocalIRK)|controller(localIRK)]} ~
            RX: SCAN_REQ: >
                接受条件1: AdvA和发送的相同
                接受条件2：(ID-ScanA && PeerIRK==0 && ID-ScanA==PeerID) ||
                           (Non-RPA-ScanA && WList-Enable) ||
                           (RPA-ScanA && PeerIRK!=0 && Resolved)
<            RX: CONNECT_REQ: >
                接受条件1: AdvA和发送的相同
                接受条件2：(ID-InitA && PeerIRK==0 && ID-InitA==PeerID) ||
                           (Non-RPA-InitA && WList-Enable) ||
                           (RPA-InitA && PeerIRK!=0 && Resolved)
<        TX: ADV_DIRECT_IND: AdvA=RPA; InitA=RPA(PeerIRK)|ID-Address(PeerIRK=0 or NO) ~
            RX: CONNECT_REQ: >
                接受条件1: AdvA和发送的相同
                接受条件2：(ID-InitA && PeerIRK==0 && ID-InitA==PeerID) ||
                           (Non-RPA-InitA && WList-Enable) ||
                           (RPA-InitA && PeerIRK!=0 && Resolved && RPA-InitA!=TxPeerAddr)
<        TX: ADV_SCAN_IND: AdvA={Non-RPA|RPA=[Host(NoLocalIRK)|controller(localIRK)]} ~
            RX: SCAN_REQ: >
                接受条件：同ADV_IND's SCAN_REQ
<        TX: ADV_NONCONN_IND: AdvA={Non-RPA|RPA=[Host(NoLocalIRK)|controller(localIRK)]} ~
            RX: ignore
    |Scanner| *(acive)*
        RX: ADV_IND, ADV_SCAN_IND, SCAN_RSP: >
            接受条件：(ID-AdvA && PeerIRK==0 && ID-AdvA==PeerID) ||
                      (Non-RPA-AdvA && WList-Enable) ||
                      (RPA-AdvA && PeerIRK!=0 && Resolved)
<            TX: SCAN_REQ: AdvA=RX_ADV_PKT_AdvA RxAdd=RX_ADV_PKT_TxAdd ScanA={Non-RPA|RPA=[Host(NoLocalIRK)|controller(localIRK)]} ~
        RX: ADV_DIRECT_IND: >
            接受条件1：(ID-AdvA && PeerIRK==0 && ID-AdvA==PeerID) ||
                       (Non-RPA-AdvA && WList-Enable) ||
                       (RPA-AdvA && PeerIRK!=0 && Resolved)
            接受条件2：(ID-InitA && LocalIRK==0 && ID-InitA==Local) ||
                       (Non-RPA-InitA && Non-RPA-InitA==Local) ||
                       (RPA-InitA && LocalIRK!=0 && Resolved)
<            TX: NO ~
        RX: ADV_NONCONN_IND: >
            接受条件：同ADV_IND
<            TX: NO ~
    |Scanner| *(passive)*
        RX: ADV_IND, ADV_SCAN_IND: >
            接受条件：同Scaner(active)'s ADV_IND
<            TX: No ~
        RX: ADV_DIRECT_IND: >
            接受条件：同Scaner(active)'s ADV_DIRECT_IND
<            TX: NO ~
        RX: ADV_NONCONN_IND: >
            接受条件：同ADV_IND
<            TX: NO ~
    |Initiating|
        RX: ADV_IND: >
            接受条件：同Scanner's ADV_IND
<            TX: CONNECT_REQ: AdvA=RX_ADV_PKT_AdvA RxAdd=RX_ADV_PKT_TxAdd InitA=Host(NoLocalIRK)|controller(localIRK) ~
        RX: ADV_DIRECT_IND: >
            接受条件：同Scanner's ADV_DIRECT_IND
<            TX: CONNECT_REQ: AdvA=RX_ADV_PKT_AdvA RxAdd=RX_ADV_PKT_TxAdd InitA=Host(NoLocalIRK)|controller(localIRK, not same as RX_ADV_PKT_InitA) ~
        RX: ADV_SCAN_IND, ADV_NONCONN_IND: >
            Ignore
<
    NOTE: 解析过程为：先遍历可解析表的所有PeerIRK去解析PeerAddress, 如果可解析, 再使用对应的LocalIRK继续解析LocalAddress(如果需要);
    NOTE: local IRK只有2种值：全0和非全0, 非全0的都一样;
    NOTE: IRK如果为全0, 则表示期望相应地址为ID-Address (这种情况是违背Privacy的, 但允许出现);
    NOTE: 如果接受条件不成立, 则忽略该数据包;
    NOTE: Privacy接受后, 如果过滤协议打开, 需要把可解析表内对应的ID-Address再使用白名单过滤;
    NOTE: 接受条件1和接受条件2是"并且"的关系, 并且先判断条件1再判断条件2;
    NOTE: 如果接受条件1地址为Non-RPA-InitA，则LocalIRK和PeerIRK都无效，例如：LocalIRK==0和LocalIRK!=0均为False;
    NOTE: 如果可解析表内包含PeerID==0, 则接受任何数据包;
    NOTE: 缩写解释：
            - ID:       Identity Address (Public Address or Static Address)
            - RPA:      Resolving Pravite Address
            - Non-RPA:  Non Resolving Pravite Address
            - WList:    White List
            - ID-InitA: InitA为Identity Address
            - InitA==Local : InitA和本地target地址寄存器值相同
            - IRK==0:   IRK的每个Bit都等于0
            - IRK!=0:   并非IRK的每个Bit都等于0
            - &&:       逻辑并且
            - ||:       逻辑或者
    NOTE: 地址从属关系:
            *Advertiser*
                AdvA: local
                ScanA: peer
                InitA: peer
            *Scanner*
                AdvA: peer
                ScanA: local
                InitA: local
            *Initiating*
                AdvA: peer
                InitA: local

17. iOS连接参数
    灰色的废弃 >
    连接上的默认参数：
        interval = 30ms
        timeout = 720ms
        latency = 0
    Slave可请求的最小连接参数
        最小interval为18.75ms, 请求信息如下:
        - IOS_MIN_PARAM_INTV_MIN = 0x08
        - IOS_MIN_PARAM_INTV_MAX = 0x10
        - IOS_MIN_PARAM_TIME_OUT = 100
        - IOS_MIN_PARAM_LATENCY  = 0
    连接参数要求：
        Interval Max * (Slave Latency + 1) ≤ 2 seconds
        Interval Min ≥ 20 ms
        Interval Min + 20 ms ≤ Interval Max
        Slave Latency ≤ 4
        connSupervisionTimeout ≤ 6 seconds
        Interval Max * (Slave Latency + 1) * 3 < connSupervisionTimeout
<
    HID:
        iOS_version<=10: iOS会主动更新参数: interval=15ms letency=4  timeout=1000, 且参数更新的最小letency是4
        iOS_version>=11: slave可以请求参数：interval=15ms letency=50 timeout=5000, 貌似letency没有限制了

    测试时发现,
        iPad-Pro的接收时要求设备端发送的的preamble个数不能太少(少于8个bit会导致接收灵敏度变低)

    The accessory is responsible for the connection parameters used for the Low Energy connection. The accessory
    should request connection parameters appropriate for its use case by sending an L2CAP Connection Parameter
    Update Request at the appropriate time. See the Bluetooth 4.0 specification, Volume 3, Part A, Section 4.20 for
    details.
    The connection parameter request may be rejected if it does not comply with all of these rules:
     ● Slave Latency ≤ 30
     ● 2 seconds ≤ connSupervisionTimeout ≤ 6 seconds
     ● Interval Min modulo 15 ms == 0
     ● Interval Min ≥ 15 ms
     ● One of the following:
          ● Interval Min + 15 ms ≤ Interval Max
          ● Interval Min == Interval Max == 15 ms
     ● Interval Max * (Slave Latency + 1) ≤ 2 seconds
     ● Interval Max * (Slave Latency + 1) * 3 <connSupervisionTimeout
    Note that if an accessory requests Interval Min == Interval Max == 15 ms, some Apple devices will scale the
    interval to 30 ms to balance power and performance constraints.
    If Bluetooth Low Energy HID is one of the connected services of an accessory, connection interval down to
    11.25 ms may be accepted by the Apple product.
    The Apple product will not read or use the parameters in the Peripheral Preferred Connection Parameters
    characteristic. See the Bluetooth 4.0 specification, Volume 3, Part C, Section 12.5.


18. Preamble 个数
    Broadcom：16bit
    CSR：8bit
    Huntersun：8bit

19. CBT报错解析：
    a. BIT zero not found >
       我们发送的数据包的preamble的前面被截断了。检查radio控制的TX-setup时间是否过短

20. HS6620
    - HS6620 CEVA RX窗口 (RX_MODE == Normal):
        数字窗口：
            经典时序：
                窗口开始：tim_bit_cnt = 647 + RX_DELAY - WIN_EXT
                          /* `c_rx_pos2(625) - `c_half_win(11) + `c_crl_delay_le(40) - `c_hab_fixed_delay(5) - `c_jal_fixed_delay(2)  + s_rx_delay - rgf_win_ext; */
                窗口大小：WIN_EXT*2 + 23
                          /* {rgf_win_ext[9:0],1'b0} + `c_win_size(23)) */
            LE时序：
                窗口开始：le_cnt_ifs = 186 + SEARCH_WIN_DELAY - WIN_EXT
                          /* ((`c_ifs_val(150) - 8'd4 + 8'd40) - rgf_win_ext + r_le_delay_srch_win) */
                窗口大小：WIN_EXT*2 + 8
                          /* {rgf_win_ext[9:0],1'b0} + `c_win_size_tifs(8)) */
        射频RX_EN：
            拉高软件控制，拉低数字控制。
            窗口开始：HIGH_REG - WIN_EXT (EARLY和LATE被置1时)
            窗口大小：WIN_EXT*2 (EARLY和LATE被置1时)

    - ROM:256KB
    - RAM:128KB, 16*8KB, 默认只有第一块有电, 默认只有第一块和最后一块有时钟
        所以唤醒后，记得把reset_handler和开电的程序放到第一块
    - PHY RX 算法延时大概有40us
    - HS6620 数字信号引出：
        o_tab_rdi_ctrl[11:0]:   bit0: TX_EN
                                bit1: RX_EN
        bb/cor_sync_det:        CEVA的sync检测
        phy/sync_det:           PHY的sync检测
        bb/r_le_cnt_ifs[7:0]:   tifs值
        bb/r_bit_cnt[10:0]:     1us bit counter
        bb/r_lif_win:           CEVA的接收sync窗口
    - CEVA T_IFS_DELAY加入1bit:
        原始的T_IFS_DELAY[5:0]变为T_IFS_DELAY[6:1],
        T_IFS_DELAY[0]为LE Registers的offset0的bit1(原为保留bit)
    - CEVA tifs RX: 
        win_stant: (150 - 4) - win_ext + le_delay_search_win
        win_width: 2*win_ext + 8
    - 外设稳定时间：
      +----------------+---------+---------+---------+
      |                |   Max   |   Min   | General |
      +----------------+---------+---------+---------+
      | 24M xtal       |   8ms   |         |   2ms   | 最大稳定时间要看用的晶体如何不好确定，这里留的裕量比较大
      | 32768K xtal    |   2s    |         |   0.5s  | 最大稳定时间要看用的晶体如何不好确定，这里留的裕量比较大
      | RAM power on   |  650us  |         |  250us  | (clamp_dealy+4))*30.5
      | Flash power on |  12.2ms |   2ms   |         | GigaDevice
      +----------------+---------+---------+---------+
    - RC32K
        随温度变化：304ppm/°C
        可以校准到：253ppm
        但是射频工作时，可能影响RC32K的精度

    注意的问题：
        1、使用python脚本测试时，串口优先级高于蓝牙优先级，波特率使用115200(不要使用更高波特率，因为可能会长时间打断蓝牙执行，导致加密时出现mic error)
        2、尽量避免有其他中断优先级高于蓝牙优先级，如果必须高于蓝牙优先级的话，则该高优先级中断里避免长时间占用CPU，否则会导致蓝牙收发出问题，会导致加密时出现mic error
        3、芯片等死在CEVA上电，可能原因是32k出现问题，32k的负载电容值可能导致其启震非常慢.
        4、上电芯片就死在AFC校准处，可能芯片内部的打线出问题了
        5、ADC校准之后的LUT校准值都是0，或者ADC采集出来的数据全是0，可能原因：1. pinmux出错了; 2. pin的mode出错了，应该是悬浮输入才行。
        6、默认部分pin是上拉的，这个可能导致睡眠电流变大
        7、开DCDC就复位，原因是可能芯片外部的DCDC电感没有焊接
        8、睡眠就复位，可能原因是：模拟的retention ldo设置的电压太低，可以设置到1v试试
        9、不需要pin参加唤醒时，也需要调用pmu_wakeup_pin_set(0)
        10、2.4G的收发调制指数必须是0.5
        11、debug bus 中 phy 0 可以把RF AD的iq两路全导出来
        12、kpp使用时, 行要设置成上拉，列要设置成开漏。
        13、睡眠时3.3v lp ldo驱动能力非常弱，且高电平只到3.0v。所以外部有灯的情况下，最好灯是共阳极的
        14、芯片最好不要有IO是悬空的，会导致电流不稳
        15、芯片上拉电阻221kOHM~394kOHM, 下拉电阻141kOHM~303kOHM
        16、62xx芯片如何和6620芯片无法互通，请查下6620的config寄存器的最高bit，改bit为0时表示和nordict兼容，1才可以和62xx互通

    HS6620-A1 UNFIX BUGS:
        1. 创建连接时，我们做slave，channel map如果不是默认值，会连接不上。
        2. controler 的 number_of_acl packet 维护出错
        3. force chip into OTA mode. remap 和 reset 必须在ROM里。

    HS6620-A1-TEST
        - TX: 12mA(4dB)
        - RX: 7-8mA(和AGC有关系)
        - CPU: 108uA/MHz (gate:2.6mA 24MHz:4.3mA 48MHz:6.9mA)
        - CEVA1: 1.3uA CEVA2:0.4uA CEVA3:3.2uA
        - 32kHz Xtal: 0.7uA
        - 32kHz RC: 20uA (A2可以达到2uA)
        - Default GPIO debug mode current:
            GPIO16 1.2mA  24M clkout
            GPIO17 0.9mA 24M clkout
            GPIO18 2.5mA 48M clkout
            GPIO19 1mA 24M clkout
            GPIO20 0.86mA 24M clkout
        - SRAM每块(8K): 0.86uA (工艺越好静态功耗越高，动态功耗越低) (QN9020 .11工艺 0.3-0.4uA)
        - Boya SF BY25D40A, deep sleep: 1.8uA, CS low: 12uA
        - 3.3v lp 打开的话，sflash的电就会被打开。这个问题A2会解决
        - GPIO驱动：15mA
        - 负载电流：30mA

        ---------------------------------------------------------------------------------------------------------------------
        Jlink-SWD: 0.18mA

        ---------------------------------------------------------------------------------------------------------------------
        PSO with DCDC-OFF (mA):
                    NO      ANA     CEVA    2.4G    PHY     SF      TIMER   UART0   UART1   I2C     SPI     GPIO    1-RAM-OFF
        CPU-GATE    2.420   3.45    2.82    2.76    2.51    2.72    2.80    2.47    2.55    2.75    2.57    2.45    2.416
                            +1.03   +0.40   +0.34   +0.09   +0.30   +0.38   +0.05   +0.13   +0.33   +0.15   +0.03   -0.004

        ---------------------------------------------------------------------------------------------------------------------
        PMU with DCDC-OFF (mA)
                    NO      CY24M-OFF   RC24M-ON    BUF_PLL-ON  PLL_ALL-ON  RF_LDO-ON
        CPU-GATE    2.420   0.32        2.67        2.46        6.63        9.69mA

        ---------------------------------------------------------------------------------------------------------------------
        CYSTAL-24M: ANA:500uA  DIG:1.6mA
        DCDC:       ON:1.49mA  OFF:2.42mA (CPU GATE)

                DIG     CRYSTAL-PMU
        2.42mA  1.6mA   0.82mA

        ---------------------------------------------------------------------------------------------------------------------
        PHY       ADC_RST  total   ANA     DIG      => PHY      (ADC_RST: yes is PHY no data input)
        not_gate  NO       23.8mA  11.1mA  12.7mA
        gate      NO       20.3mA  11.9mA   8.4mA      4.5mA
        not_gate  YES      21.3mA  11.1mA  10.2mA
        gate      YES      19.4mA  11.1mA   8.3mA      1.9mA

        DIG(7.4mA) = phy + ceva_mac + 2.4_mac + wfi_gate_xxx

    HS6620-A0-BUG
        软件相关：
            1、calib_rf_afc()中的AFC校准，不能做第二次。影响客户调试
               [解决] 影响客户调试
            2、APP大小过小时(几百个字节)，导致boot出问题
               [解决]
            3、CPU没有被gate掉(wfe)
            4、cfg_init/load_patch时，如果内部flash没有patch数据时，会查找外部flash，这样会不期望的改变pinmux
            5、patch时钟没开
               [解决]
            6、sflash：BY25D40A   684013
            7、ISP工具：
               a、erase flash之后，烧写flash，会导致程序死掉
               b、当别的设备占用串口时，点击connect无提示
               c、ISP工具在第1次和芯片bootloader连接时，常出问题，第2次就好了
            8、作为slave时，做批量测试后，会导致小概率出现再也无法收到数据的问题
               [解决] 原因是射频结束后HWle_clear_tifs_default()应该晚于HWle_clear_tx_enable()，
                      HWle_clear_tifs_default是ceva收发时使用bit_counter或者tifs_counter的选择位，
                      所以调用HWle_clear_tx_enable要优先于HWle_clear_tifs_default，防止刚选择完，该counter就到了，tx就启动了。
            9、广播收到连接请求后，如果延时60us左右再bba_end(), 会导致之后无法收到数据
               [解决] 数字状态机会在这60us内启动发送，而后软件无法强制结束掉它。解决方法：收到连接请求后，立即终止CEVA内各种状态
            10、patch，客户调试时，如果重新执行，会导致patch不会被重新加载，已经加载co_malloc会被重新初始化
            11、trace ID， 每个客户ID不同，和6601相同做法
            12、跑48MHz sflash必须把flash时钟的sample delay=5

        其他：
            1、sflash的pad有问题 ~
               [解决] ECO
            2、PSO_ON_EN打开，睡眠后，jlink会断掉 ~
            3、睡眠唤醒： ~
               a、[XXX] 只有PSO_ON_EN打开时，可以睡眠唤醒，且几次唤醒后，会死在广播状态（应该是某个BLE中断没有按预期产生，没有睡眠的程序不会出现这个问题）。 当PSO_ON_EN关闭后，睡眠后唤醒会导致CPU从ROM里执行（测试时发现flash里的代码被加载到RAM里了，猜测REMAP没有起作用）
                  [进展] 当不调用pmu_gpio_wakeup_set(PMU的GPIO_MASK)时，可以正常睡眠唤醒
                  [进展] 数字接口供电问题，使用外部电源可以正常睡眠唤醒工作
                  [解决] Flash Pad问题
            4、PSO_ON_EN打开时，睡眠唤醒后，会等死在“AFG校准恢复”里 ~
               [解决] ana的时钟没有打开
            5、和标准的BLE芯片连接，CRC_ERROR的包特别多。 ~
               使用CBT测试时，发现超大概率第一个包收错，且错误原因是CRC_ERROR。
               [初步分析] 发现数据包头(len)固定错了一个bit，抓ADC信号仿真，发现ADC信号有些问题
               [进展] AGC的ADC有问题，关掉该ADC时，会出现小于1us的抖动，导致1个bit出错。
               [解决] 不关该ADC
            6、当使用Boya的sflash(BY25D40A)时，重启成功的条件是：掉电的时间长一些 ~
               [进展] 掉电是，sflash的LDO从3.3v降到0v时间比较长，导致boya的flash出问题
               [解决] 把sflash的hold和wp挑掉就好了
            7、GPIO6(UART-IN)会影响芯片工作：如果把GPIO6的跳线帽跳上，芯片可以正常跑起来。否则，大概率芯片跑步起来，jlink也连不上。 ~
               把所有GPIO配置成上拉可以解决这个问题
               [进展] 把只有会进入睡眠的程序会出现这个问题，不进入睡眠的程序工作正常
               [进展] 数字接口供电问题，使用外部电源可以正常工作
               [解决] 软件问题，UART输入悬浮时，会导致串口收到乱七八糟的数据。GPIO6加上拉
            8、3.3v sflash 不能单独关电，所以sflash不能断电，GD的flash的lowpower电流是最大5uA。准备使用Boya的flash是3.3v的 ~
               1.8v sflash 可以单独关电
               [解决] 模拟会做ECO，把flash的供电分离出来
            9、睡眠后醒来，射频工作异常 ~
               [解决] 1.唤醒后校准数据恢复出问题；2.数字CPM时钟打开后需要3个APB时钟，导致有些DAIF寄存器写入出错
            10、PSO_ON_EN，校准恢复会挂死 ~
            11、MASTER事件结束后，无法避免会出现一个TXEN的毛刺(TXEN控制时间太紧张)，会导致接下来的就收无法收到数据 ~
               [解决] 数字的数模接口状态机有问题，这个毛刺会导致状态机停在等vtrack的状态而无法出来。解决方法是：开关vtrack来复位状态机
            12、shutdown中断开机就pending上的 ~
                [进展] 初始化时清下GPIO中断，并且需要延时100us后再使能shutdown功能. 但是睡眠状态下无法通过shutdown pin唤醒
                [解决] 醒了之后不再进入睡眠了就可以工作，需要ECO：软件可以读到外部shutdown pin的状态
            13、rc24M校准在睡醒后无法重新进行校准，reset数模接口后也不行 ~
            14、睡眠后马上唤醒，可能导致PMU里给软件预留的寄存器值复位 ~
                [进展] PMU没有复位，感觉PMU软件预留寄存器值某些情况下无法写进去
            15、默认pin16-20为输出pin，是否修改为输入pin
            16、有些芯片使用一段时间会死在等CEVA上电处
                [解决] 外部32768K晶体管脚断了
            17、DMA使能情况下，进入WFI会导致DMA出问题
            18、ADC测外部电压时会高100mV左右，需要在量产测试时将校准值写入SFLASH
            19、I2S PSO里时钟gate不可读
            20、PHY在RX TX时候会消耗4mA
            21、I2C bug：DATA_CMD和RX_EN直接必须加9us的延时
            22、RX模拟的ADC信号有DC
            23、PHY在算RSSI时，没有把filter gain计算进去
                [解决] 软件把filter_gain_index读出来，再加回到RSSI中去
            24、PHY的软判决会提高3个db灵敏度

    HS6620-A2-TEST
        - 32k RC: 2.5uA
        - deep sleep: 6.2uA(ret ldo 0.9v)  7uA(ret ldo 0.95uA)  7.5uA(ret ldo 1v) (1SRAM)
        - Per SRAM:   0.85uA(ret ldo 0.9v) 1.1uA(ret ld0 0.95v) 1.3uA(ret ldo 1v)
        - 5 block SRAM Retention, deep sleep:
          内部上拉，所有IO输出低:  236.4uA
          内部上拉，所有IO输出该:  12.0uA
          内部下拉，所有IO输出高:  426.4uA
          内部下拉，所有IO输出低:  12.0uA
          内部悬浮，所有IO输出高:  12.0uA
          内部悬浮，所有IO输出低:  12.0uA
          内部上拉，所有IO输入:    12.0uA
          内部下拉，所有IO输入:    12.0uA
          内部悬浮，所有IO输入:    15.4uA
        - flash ldo关掉深睡眠：12uA
          flash ldo开着深睡眠：240uA
          flash ldo开着深睡眠，并且把flash供电的跳线帽拔掉：180uA
        - DCDC on:  IDLE:1.40mA  ACTIVE(24MHz):2.50mA  TX(0dB):11.23mA  RX:10.72mA
          DCDC off: IDLE:2.35mA  ACTIVE(24MHz):3.98mA  TX(0dB):19.03mA  RX:18.00mA

        ---------------------------------------------------------------------------------------------------------------------
        PSO with DCDC-ON (mA):
        ROM-PATCH   CEVA    2.4G    PHY     SF      TIMER   UART0   UART1   I2C     SPI     GPIO    1-RAM-OFF
        +280uA      +150uA                                                                  +20uA

        ---------------------------------------------------------------------------------------------------------------------
        PSO with DCDC-ON (mA):
        CPU gate时，CPU=1MHz，0.99mA (CEVA and GPIO open) (模拟占578uA)

        问题：
            1. retention ldo 必须设置成0.95v，否则可能导致醒不来 (解决，设置成0.95v)
            2. 当PMU_ANA_TEST_EN_DISABLE_MASK=0时，reset管脚连续8个脉冲会使芯片进入数字的test mode (解决，A3 ROM里上来就把其设置成1)
            3. 2.4G接收时，软判决会导致sync后有3bytes的多余的0。硬判决好 (解决，A3改好)
            4. 2.4G发送后睡眠，会导致下一次唤醒的发送数据的PID和睡眠之前的发送包的数据相同. 如果payload再相同，则会导致接收方收不到数据。(解决办法是在payload上加一个字节的计数器。)
            5. 开机功能时：开机时，如果当电压是0.5v时，抬起按键，会导致再也无法开机。 (解决，A3改好)
            6. 如果发现DCDC开时，芯片睡眠唤醒多次后，出现复位的情况，可能是由于DCDC电感有问题导致。(解决，不用DCDC了)
            7. xtal24m加负载电容的话，可能会导致快速起振变慢。(负载电容要匹配)
            8. 如果sleep timer 先唤醒芯片 然后gpio来中断了，这时gpio中断可能丢 (数字不解决)
            9. 看门狗复位所有东西，且给标志 (数字不解决)
            10. 如何设置24M晶体的快速启震和正常启震

        待修改：
            1. OTA时的DCDC，读取cfg数据，得到DCDC开关状态 (不用DCDC了)
            2. PUYA flash在某些情况下重新mount 会出错 （解决）
            3. 当有两个按键同时来唤醒芯片的时候，会导致有一个丢了 (不解决了)
            4. i2c会挂的问题 ()
            5. spi中间电平的问题（两个字节中间） （解决）
            6. 有颗芯片在不同电压下行为不一样。3.6v:启动很快 4.0v:启动很慢 4.2v:死在ceva上电 (可能是32k晶体导致的)
            7. 用外部flash时，sf_enable不用开电. 
            8. OTA模式时 串口来异常数据（解决）
            9. 看门狗机制（解决）
            10. 应用里的静态地址 cfg（解决）
            11. bootloader里重新考虑 HS_PMU->BOOT_SEL (HS_PMU->AHB_REMAP & PMU_WDT_RESET_MASK)（解决）
            12. deep sleep: wdt_restore（解决）
            13. cfg只烧写有效数据

        电池电压不准，因为假如ad出来是准确的4.1v，但是可能把充电器拔下来，可能就是4.0v了。
        一般AD测充满是这个算法：AD测充满，然后关闭充电电路，再测一次，
        6620中模拟检测充满的的状态，是当充电电流小到一定程度是报的，但是有些锂电池内阻较大(分压，自身耗电)，
        导致电流会一直有，这样模拟的充满状态可能永远也不会报上来。所以最后的有效检测充满的方法是：
        用AD检测电压大于多少V，如果大于的话，则再充半个小时，则认为充满了。

    HS6620-A3-TEST
        看门狗增加的功耗：2.2uA = 25.2uA(有看门狗时的电流) - 23.0uA(无看门狗时的电流)

    原相 BLE键盘评测 (PAR2801)：
        1. sleep: 45uA （保持连接）
        2. 待机：200uA
        3. 工作：1.45mA
        4. Manufacturer: 0x093A

    雷柏MT750鼠标BLE测评：
        1. 没有32768k xtal
        2. 2.4G上报率125，ble上报率114
        3. ble用一段时间就不动了。原因是笔记本不在发送数据包，因为“假latency”
        4. RPA地址不会变
        5. 连接3个设备，使用3个广播地址

    罗技M720鼠标评测：
        未配对广播状态：
            ADV_IND  F6:C9:B9:64:D2:9E (Static), LimitedDiscoverable, Appearance=Mouse, Services=Human Interface Device, Name="M720 Triathlon"
            SCAN_RSP F6:C9:B9:64:D2:9E (Static), Tx Power=4 dBm
        配对后广播状态：
            ADV_IND  F6:C9:B9:64:D2:9E (Static), Appearance=Mouse, Services=Human Interface Device, Name="M720 Triathlon"
            SCAN_RSP F6:C9:B9:64:D2:9E (Static), Tx Power=4 dBm
            无直接广播
        总结：M720没有privacy，没有直接广播，配对和未配对广播的区别是LimitedDiscoverable

    微克手环F1：
        ldo: 10uA
        LCD: 2uA (close)
        heartrate: 320uA(led blink) 2uA(sleep)
        acceleration: work-4ms-200uA, sleep-61ms-10uA

        未开机：60uA(sensor都睡)
        开机不动30s后：70uA(acceleration周期唤醒: work-4ms-200uA, sleep-61ms-10uA)

    Nordic 手环:
        只是定时器醒的话，唤醒需要500uA

    鼠标sensor的扫描间隔：
        移动：          6.5ms
        停止移动：      36ms
        停止移动25s后： 140ms

    BLE异常手机测试：
        vivo X20A：
            Android 7.1.1, 基带660_GEN_PACK-1.116988.1.117079.3，ROM3.2
            bluetooth:
                'manuf_name': Qualcomm
                'lmp_ver': V5.0
                'lmp_subver': 702
            问题：
                接收灵敏度差，经常收不到不到对方的包，导致大量重传，严重时断开连接。
                不是每次都出问题，多重连几次，就会大概率出现问题

        手机射频接收性能差的蓝牙型号：
            MediaTek v4.1 1049
            Qualcomm v4.1 2003
            Qualcomm v5.1 702


    下一版BLE芯片希望的改动：
        1.  某些极端情况下需要48MHz CPU来跑CEVA的逻辑: 因为软件要处理PKA/PKD。且由于时序太紧张，导致TXEN或RXEN会出现毛刺。
        2.  提高xtal24m晶体起振速度
        3.  CPU gate时，功耗较大，希望尽量多的gate掉无用时钟。
        4.  深睡眠时，4uA数字底电流过大。
        5.  RC32K精度做到500ppm，且校准时不会影响其精度，以降低功耗
        6.  去掉CEVA的use_lf的时间，以降低睡眠和唤醒时间
        7.  slave模式时不要要同步远方master时钟，降低唤醒时间
        8.  唤醒时，xtal24m和其他的某些起振能否并行处理
        9.  温度大于50度时，否不能做到不用增加rf的电流
        10. ESD和浪涌防护不够，静电损坏和老化问题
        11. 多个按键同时唤醒芯片时，数字需要latch住所有IO状态。
        12. 更优雅的短脉冲唤醒策略 <100us
        13. gpio模块不能搞成gpio0,gpio1。统一搞成1个gpio模块，以提高gpio操作效率
        14. gpio模块是否能使用32k驱动，睡眠时retention。这样就不用又在pmu里搞个io唤醒了。软件绕这两个模块
        15. 增加I2C模块个数, 上拉电阻大会出问题
        16. 现在数字的kpp已经废弃，期望改动：1.pin不固定 2.睡眠时可以工作
        17. encoder模块在鼠标应用中无法使用，原因是睡眠后无法工作，期望增加32k驱动选项
        18. watchdog期望睡眠时可用。
        19. 是否有好办法不挑dcdc电感电容
        20. xtal32k内部负载电容范围加大，现在最大12pF
        21. PHY在TXRX时有4mA的功耗，需要降低
        22. PHY在算RSSI时，没有把filter gain计算进去
        23. IO反灌电的问题
        24. flash ldo耗电过大
        25. 睡眠时和唤醒后的IO输出电压有压差，导致灯闪，3.0v和3.3v
        26. 发射功率提高
        27. preamble个数可调节
        28. 关机漏电慢问题
        29. 16bit ADC for audio
        30. 开机变砖问题
        31. 充电器插入开机
        32. DCDC挑电感，效率低
        33. 在系统工作在3.3v时，adc采>3.3v电时 会导致芯片出问题
        34. debug bus睡眠
        35. SPI接收数据时，要求其时钟是CPU时钟的8倍以下
        36. ADC校准值数字自动算，这样用DMA时就方便了
        37. CPU PC指针recorder
        38. 死机调试模式
        39. 更好的 xtal24M & xtal32k ready信号
        40. 不要让软件做死等的操作，需要软件等待的，数字要给标志
        41. 数字提供示例程序
        42. 估测电流图，每个模块电流可以独立测算
        43. 睡眠时，数字自动维持IO输出电平
        44. rc32k校准时无缝切换 32768-32000 相位（RTC）
        45. Patch：如果patch打在2字节对齐（非4字节对齐）的位置，如果该2字节对齐的位置的上面是4字节的指令，会导致这个4字节指令出错


        没有经历过睡眠的情况下，导致无法等到晶体的状态。导致看门狗等复位手段失效。

    API修改：
        1. co_power_register_sleep_event 参数: typedef void (*co_power_sleep_callback_t)(co_power_sleep_state_t sleep_state, co_power_status_t power_status);
        2. pmu_force_into_isp_mode -> pmu_force_into_ota_isp_mode
        3. PMU_REBOOT_FROM_ISP -> PMU_REBOOT_FROM_OTA_ISP
        4. cpft 时的sf_write不能用了，使用sf_write_page替代
        5. 删除gpio的单沿触发的模式, 且回调中加入了pin_level_mask参数


    Ellisys:
        vanguard: 6.7w刀
        tracker_pro: 2w刀 (1.9w)
        explorer_pro: 4.6w刀
        explorer_std: 3.9w刀
        SIG会员85折
        孙皓(销售): 15801471720, hao.sun@ellisys.com

    HS6620 PUYA(0x856013) flash speed test:
        size=100kB sfspeed=6MHz  sfwith=1 erase=178ms write=842ms  read=216ms
        size=200kB sfspeed=6MHz  sfwith=1 erase=357ms write=1684ms read=433ms
        size=300kB sfspeed=6MHz  sfwith=1 erase=536ms write=2527ms read=650ms
        size=400kB sfspeed=6MHz  sfwith=1 erase=715ms write=3369ms read=867ms
        size=100kB sfspeed=6MHz  sfwith=2 erase=178ms write=842ms  read=109ms
        size=200kB sfspeed=6MHz  sfwith=2 erase=357ms write=1684ms read=218ms
        size=300kB sfspeed=6MHz  sfwith=2 erase=536ms write=2527ms read=327ms
        size=400kB sfspeed=6MHz  sfwith=2 erase=715ms write=3369ms read=437ms
        size=100kB sfspeed=6MHz  sfwith=4 erase=178ms write=842ms  read=58ms
        size=200kB sfspeed=6MHz  sfwith=4 erase=357ms write=1684ms read=117ms
        size=300kB sfspeed=6MHz  sfwith=4 erase=536ms write=2527ms read=175ms
        size=400kB sfspeed=6MHz  sfwith=4 erase=715ms write=3369ms read=234ms
        size=100kB sfspeed=12MHz sfwith=1 erase=177ms write=687ms  read=80ms
        size=200kB sfspeed=12MHz sfwith=1 erase=354ms write=1375ms read=160ms
        size=300kB sfspeed=12MHz sfwith=1 erase=531ms write=2062ms read=240ms
        size=400kB sfspeed=12MHz sfwith=1 erase=708ms write=2750ms read=320ms
        size=100kB sfspeed=12MHz sfwith=2 erase=177ms write=687ms  read=40ms
        size=200kB sfspeed=12MHz sfwith=2 erase=354ms write=1375ms read=81ms
        size=300kB sfspeed=12MHz sfwith=2 erase=531ms write=2062ms read=122ms
        size=400kB sfspeed=12MHz sfwith=2 erase=708ms write=2750ms read=163ms
        size=100kB sfspeed=12MHz sfwith=4 erase=177ms write=687ms  read=22ms
        size=200kB sfspeed=12MHz sfwith=4 erase=354ms write=1375ms read=45ms
        size=300kB sfspeed=12MHz sfwith=4 erase=531ms write=2062ms read=68ms
        size=400kB sfspeed=12MHz sfwith=4 erase=708ms write=2750ms read=91ms
        size=100kB sfspeed=24MHz sfwith=1 erase=178ms write=690ms  read=46ms
        size=200kB sfspeed=24MHz sfwith=1 erase=356ms write=1381ms read=92ms
        size=300kB sfspeed=24MHz sfwith=1 erase=535ms write=2072ms read=138ms
        size=400kB sfspeed=24MHz sfwith=1 erase=713ms write=2762ms read=184ms
        size=100kB sfspeed=24MHz sfwith=2 erase=178ms write=690ms  read=23ms
        size=200kB sfspeed=24MHz sfwith=2 erase=356ms write=1381ms read=47ms
        size=300kB sfspeed=24MHz sfwith=2 erase=535ms write=2072ms read=70ms
        size=400kB sfspeed=24MHz sfwith=2 erase=713ms write=2762ms read=94ms
        size=100kB sfspeed=24MHz sfwith=4 erase=178ms write=690ms  read=14ms
        size=200kB sfspeed=24MHz sfwith=4 erase=356ms write=1381ms read=28ms
        size=300kB sfspeed=24MHz sfwith=4 erase=535ms write=2072ms read=42ms
        size=400kB sfspeed=24MHz sfwith=4 erase=713ms write=2762ms read=56ms


21. HS6621FPGA:
    线损：3.2dBm
    NF: 4.8dBm
    硬判决：
        2MHz    -90.5dBm
        1MHz    -93.2dBm
        500kHz  -99.0dBm
        125kHz  -103.0dBm
    软判决：
        2MHz    -93.2dBm
        1MHz    -96.2dBm
        500kHz/125kHz不支持软判决

22. PUYA Flash 的那些坑：
    1. 写1bytes和写256bytes耗时都是2ms；
    2. 擦除时间真是短8ms（有page擦除）；
    3. 不擦除的情况下，每个bit都可以从0写成1；
    4. 写的长度为0时，会造成后面的写操作出错；

    PUYA工程师的邮件：
        PUYA的flash program都是以整个page program方式的。
        program一个page数据时，编程指令直接送入>= 256byte的数据，芯片直接执行编程动作。
        只program一个byte或少于256byte时，芯片会做算法来内部读未编程地址的数据来补满一个page编程数据。
        由指令送入数据的地址不会care原来cell里是什么数据，整个page写入补满成一个page的编程数据。
        Byte program时的处理过程是1）读内部数据，补满整个page    2）byte program预处理   3）page program
        在byte program预处理时，program成“0”的cell可能会变成“1”。但写入数据是“0”时，该cell又会被program成“0”。（写入数据与原来cell数据“与”处理在这时候起作用）
        每一次byte program时，都是对整个page做一次program。所以如果一个page有多次byte或bit方式的program，可能会影响该page擦写次数。
        采用byte program时编程时间比其他传统flash要长。但在最小erase区间，erase时间，功耗等各个方面有明显优势。

23. 认证
    HS6620 BLE BQB 认证 （4.2 Endproduct, BITE）（2016/08/xx）
        1.1 BT LE RF PHY（1Ms）testing           ¥21,000.00
        1.2 BT LE Controller protocol testing    ¥24,000.00
        1.3 BT LE Hoster protocol testing        ¥30,000.00
        1.4 BT BQE review                        ¥20,000.00
                                                 ¥95,000.00

    HS6620 BLE BQB 认证 （5.1 Component, Frontline Harmony） （2019/06/11）
        1.1 BT LE RF PHY（1Ms）testing           ¥15,000.00   核心版本5.1,测试内容4.2
        1.2 BT LE Controller protocol testing    ¥60,000.00   核心版本5.1,测试内容4.2
        1.3 BT LE Hoster protocol testing        ¥40,000.00   核心版本5.1,测试内容4.2
        1.4 BT BQE review                        ¥20,000.00   all TCs
                                                 ¥135,000.00

    HS6620 性能测试（2016/08/22）
            Item                                 Hour   Unit price   Price(RMB)   Comment
        1.1 射频性能：vco相噪 110dBc@1MHz        2      ¥1,500.00    ¥3,000.00    计时测试，客户自带测试列表
        1.2 电压范围：2.7V-4.2V                  2      ¥1,500.00    ¥3,000.00    计时测试，客户自带测试列表
        1.3 功耗：发射功耗3.5mA，接收功耗3.5mA   2      ¥1,500.00    ¥3,000.00    计时测试，客户自带测试列表
        1.4 封装尺寸4X4mm QFN封装                2      ¥1,500.00    ¥3,000.00    计时测试，客户自带测试列表
        1.5 Report Fee                           1      ¥2,000.00    ¥2,000.00
                                                        Total(RMB)   ¥14,000.00

    PQ号        项目号      Model       Testing     联系人  状态    发票/Invoice金额（RMB）     时长
    PQ201800247 I18Z60168   HS6620      CE          肖金红  完成    ￥12,500.00                 5小时
    PQ201801417 B18Z60991   HS6206A6    CE          肖金红  完成    ￥3,750.00                  1.5小时
    PQ201900364 I19Z60300   HS6209      CE          肖金红  完成    ￥8,750.00                  3.5小时
    PQ201901535 B19Z61093   HS662X      BT SIG      李强    完成    ￥135,000.00
　
24. 定时器对齐

    2个20ms定时器，每个定时器工作1ms，无RF，无DCDC
        align:   1.40mA
        unalign: 1.97mA
        对齐减少30%的功耗

    2个50ms定时器，每个定时器工作100us，无RF，无DCDC
        align:   340uA
        unalign: 570uA
        对齐减少40%的功耗

    1个8ms定时器，定时器内发一包，7.5ms连接间隔，无DCDC
        align:   4.65mA
        unalign: 5.20mA (5.74mA 最坏)
        对齐减少10%-25%的功耗

    1个15ms定时器，定时器内发一包，15ms连接间隔，无DCDC
        align:   2.50mA
        unalign: 3.30mA (最坏，大部分是最坏情况)
        对齐减少25%功耗

    1个100ms定时器，定时器内发一包，100ms连接间隔，无DCDC
        align:   420uA
        unalign: 550uA (最坏，大部分是最坏情况)
        对齐减少25%功耗

25. 新的芯片 idea
    1. 关机功能能否和普通IO做到一个PIN上去，这样像手环应用关机就可以真关机了
    2. 睡眠后数字自动存储IO状态：给软件一个配置，哪些不自动控制的，用于jlink调试
    3. PINMUX默认值不能是功能

26. HS6621 flash控制器和SPI性能：
    flash控制器读flash时()：
        每32bytes, 大概有0.5个时钟周期的间隙
    flash控制器刷LCD(双通道)时(CPU:32MHz, SPI:1MHz)：
        每18bits, 大概有0.5个时钟周期的间隙
        每8*18bits, 大概有1.5个时钟周期的间隙
    flash控制器刷LCD(双通道)时(CPU:32MHz, SPI:32MHz)：
        每18bits, 大概有10个时钟周期的间隙 (数据:570ns(18bits),间隙1:310ns,间隙2:750ns)
        每8*18bits, 大概有24个时钟周期的间隙
        损失了40%的速度
    裸SPI控制器(CPU:32MHz, SPI:4MHz):
        每8bits，有3个时钟周期的损失
    间隙和CPU速度有关系！！！

27. HS6621A1 测试

    SRAM: @3.3v
        12.9uA:  ULP:32kB*4(nodeepsleep)     LP:all_close rc32k:open
        9.4uA:   ULP:32kB*2(nodeepsleep)     LP:all_close rc32k:open
        7.8uA:   ULP:32kB*1(nodeepsleep)     LP:all_close rc32k:open
        10.9uA:  ULP:32kB*4(32k*3:deepsleep) LP:all_close rc32k:open

        112.0uA: ULP:32kB*4(nodeepsleep)     LP:8kB*16(nodeepsleep) rc32k:open
        105.4uA: ULP:32kB*4(nodeepsleep)     LP:8kB*15(nodeepsleep) rc32k:open
        87.5uA:  ULP:32kB*4(nodeepsleep)     LP:8kB*12(nodeepsleep) rc32k:open
        32.3uA:  ULP:32kB*4(nodeepsleep)     LP:8kB*16(deepsleep)   rc32k:open

        ULP: 1.75uA/block(32kB) (nodeepsleep)
        ULP: 1.03nA/block(32kB) (deepsleep)

        LP:  6.125uA/block(8kB) (nodeepsleep)
        LP:  1.216uA/block(8kB) (deepsleep)

    32k: @3.6v
        RC32k: 6.9uA(close)    6.9uA(open)
        xtal32k: 6.9uA(close)  6.3uA(open)

    @3.3v
        DIG_LDO_V0P9_RET_VBAT:1.00v     10.2uA
        DIG_LDO_V0P9_RET_VBAT:0.95v     9.1uA
        DIG_LDO_V0P9_RET_VBAT:0.90v     8.1uA
        DIG_LDO_V0P9_RET_VBAT:0.85v     7.4uA
        DIG_LDO_V0P9_RET_VBAT:0.80v     6.8uA
        DIG_LDO_V0P9_RET_VBAT:0.75v     6.1uA
        DIG_LDO_V0P9_RET_VBAT:0.70v     5.7uA
        DIG_LDO_V0P9_RET_VBAT:0.65v     5.2uA

    chip             #8         #2
        Vbat 4.2v:   8.9uA      8.6uA
        Vbat 4.1v:   7.6uA      7.7uA
        Vbat 4.0v:   7.4uA      7.5uA
        Vbat 3.9v:   7.2uA      7.4uA
        Vbat 3.8v:   7.1uA      7.3uA
        Vbat 3.7v:   7.0uA      7.2uA
        Vbat 3.6v:   6.9uA      7.1uA
        Vbat 3.5v:   6.9uA      7.1uA
        Vbat 3.4v:   6.8uA      7.0uA
        Vbat 3.3v:   7.1uA      7.3uA
        Vbat 3.2v:   7.0uA      7.2uA
        Vbat 3.1v:   6.9uA      7.1uA
        Vbat 3.0v:   6.9uA      7.1uA
        Vbat 2.9v:   6.8uA      7.0uA
        Vbat 2.8v:   6.7uA      7.0uA
        Vbat 2.7v:   6.7uA      7.0uA
        Vbat 2.6v:   6.7uA      6.9uA
        Vbat 2.5v:   6.6uA      6.9uA
        Vbat 2.4v:   6.6uA      6.9uA
        Vbat 2.3v:   6.5uA      6.8uA
        Vbat 2.2v:   6.5uA      6.8uA
        Vbat 2.1v:   6.4uA      6.8uA
        Vbat 2.0v:   6.4uA      6.7uA
        Vbat 1.9v:   6.4uA      6.7uA
        Vbat 1.8v:   6.3uA      6.6uA
        Vbat 1.7v:   6.3uA      6.6uA
        Vbat 1.6v:   6.2uA      6.5uA

    __WIF:
        2.10mA XTAL32M      ANA:0.66mA
        2.46mA RC32M        ANA:0.60mA

                        pd_io_ldo=1     pd_ret_ldo=1、pd_io_ldo=1       =0 =0 (ret_ldo=1v)
    整体电流    7.4uA   6.8uA           350uA                           10uA
    模块电流            600nA           

    pd_ret_ldo=0、pd_io_ldo=0
        ret_ldo=0.85v  ret_ldo=1v
        7.4uA          10uA

    ret_ldo: 350nA
    io_ldo: 600nA

    RC32K:   1.7uA (7.4-5.7)
    XTAL32K: 1.0uA (6.7-5.7)

    Flash LDO: 10uA

    PHY: 1.6mA(7.0-5.4,DCDC-on)  3.73mA(15.73-12.0,DCDC-off)
    RX: 7.0(DCDC-on) 15.73(DCDC-off)
    TX: 5.68mA(0dBm,DCDC-on) 12.8mA (0dBm,DCDC-off) 6.57mA(3.1dBm,DCDC-on) 14.9mA(3.1dBm,DCDC-off)

    5.7uA:  RET_LDO:0.85v(实际0.875v) vbat=3.3v (ANA:1.25uA DIG:2.7uA ULPSRAM:1.75uA) (1ulpRAM, 32K close)
    7.1uA:  RET_LDO:0.85v(实际0.868v) vbat=3.3v (ANA:1.25uA                         ) (2ulpRAM, 32K close)
    9.0uA:  RET_LDO:0.85v(实际0.860v) vbat=3.3v (ANA:1.25uA                         ) (3ulpRAM, 32K close)
    10.4uA: RET_LDO:0.85v(实际0.855v) vbat=3.3v (ANA:1.25uA                         ) (4ulpRAM, 32K close)

    4.1uA:  RET_LDO:0.70v(实际0.746v) vbat=3.3v (ANA:1.25uA                         ) (1ulpRAM, 32K close)
    5.0uA:  RET_LDO:0.70v(实际0.   v) vbat=3.3v (ANA:1.25uA                         ) (2ulpRAM, 32K close)

    chip #11 (1st ULPRAM: nodeepsleep)
        5.5uA  RET_LDO:0.85v(实际0.882v) vbat=3.3v ULPRAM:0001
        6.8uA  RET_LDO:0.85v(实际0.875v) vbat=3.3v ULPRAM:0011 (nodeepsleep) 6.8-5.5 = 1.3
        7.1uA  RET_LDO:0.85v(实际0.873v) vbat=3.3v ULPRAM:0101 (nodeepsleep) 6.9-5.5 = 1.6
        6.9uA  RET_LDO:0.85v(实际0.875v) vbat=3.3v ULPRAM:1001 (nodeepsleep) 6.9-5.5 = 1.4
        6.3uA  RET_LDO:0.85v(实际0.878v) vbat=3.3v ULPRAM:0011 (deepsleep)   6.3-5.5 = 0.8
        6.6uA  RET_LDO:0.85v(实际0.876v) vbat=3.3v ULPRAM:0101 (deepsleep)   6.6-5.5 = 1.1
        6.3uA  RET_LDO:0.85v(实际0.878v) vbat=3.3v ULPRAM:1001 (deepsleep)   6.3-5.5 = 0.8

    chip #100 (1st ULPRAM: nodeepsleep) RET_LDO:0.65v
        3.9uA (ana=1.4uA) RET_LDO:0.65v(实际0.712v) vbat=3.3v  ULPRAM:0001
        4.6uA (ana=1.4uA) RET_LDO:0.65v(实际0.702v) vbat=3.3v  ULPRAM:0011 (nodeepsleep) 4.6-3.9 = 0.7
        4.8uA (ana=1.4uA) RET_LDO:0.65v(实际0.700v) vbat=3.3v  ULPRAM:0101 (nodeepsleep) 4.8-3.9 = 0.9
        4.6uA (ana=1.4uA) RET_LDO:0.65v(实际0.702v) vbat=3.3v  ULPRAM:1001 (nodeepsleep) 4.6-3.9 = 0.7

    ECO:
        1. SRAM的deepsleep控制
        2. 快启看first_run的问题

    A1问题：
        1. 电容太大会导致快启hardware fault
        2. AGC校准后，校准程序不会停，睡眠后才会停
        3. SF 两线读的时候，dummy时的SI的输入输出控制导致大电流
        4. CPU和RAM不同频时，因为CPU优先级较高，LCD会一直得不到BUS，导致LCD状态等死
        5. 外部flash速度只约束到了48M，只影响读，不影响写，内部的约束到了72M
        6. flash透明读时，在不开cache的情况下，多Word读会出问题，例如：LDR r0, r1, [50000000]，会导致r0数据正确，r1没有数据

    A3问题：
        RTC、WDT睡眠时有5uA所有的漏电，原因是RTC模块里有SVV和SVN的器件

             2M      1M      S2      S8
    PLL144  -84     -90     -93     -96
    NOPLL   -84.6   -90.3   -93.1   -97
    PLL144  -85     -89.7   -89.1   -95.7  (CPU read/write lp RAM)

    微克手环刷屏: (360*360) (HS6621)
    读flash： 612us/16行 (2线64MHz)     16%
    解压：   1629us/16行                44%
    刷屏：   1471us/16行 (2线64MHz)     40%


2019年BLE鼠标兼容性问题汇总:
    1、导致鼠标卡顿和偶尔丢失按键
       对于蓝牙协议栈的TX buffer缓存，motion数据不需要全部占有，一般3个足够；只有按键信息才可以占用全部缓存
    2、无法在同一台win10上多次配对连接
       对于在win10上，鼠标与一电脑配对连接成功，在电脑上没有删除改鼠标，然后鼠标重   新变更地址进入配对与该电脑连接，则可以搜索到但无法与该电脑再次连接；
       原因是鼠标IRK一直没有变化，导致电脑认为该鼠标的IRK和已有设备一样，但地址不一样；导致电脑无法处理
       通过对鼠标IRK随地址变化而变化的修改后，问题消除；
    3、某些win10电脑无法回连
       鼠标的回连广播采用directed ADV无法回连部分win10电脑，需要采用undirected ADV;
       所以，回连策略针更改为：对static random地址的主机采取第一次回连用directed ADV后采用undirected ADV，这样既兼顾了directedADV的快速性又兼容了这部分异常电脑；
    4、回连时间慢
       因win10电脑在回连时，connection request里面的连接参数就已经带上了slaveLatency，所以，导致鼠标与主机通讯因latency导致连接缓慢；
       在连接未完成阶段，关闭lantency，回连速度得到大幅度提升；
    5、对BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST的响应
       鼠标对该event必须回应，使用api函数sd_ble_gap_conn_param_update进行回应，如果参数符合要求，则回复该参数即可，如果不一样，则回复想要的参数；
       对于feature没有connection parameter update procedure功能的情况，则没有这个世界；
    6、部分mac无法连接
       该兼容性问题，罗技设备也有该兼容性问题。
       由于部分mac电脑在加密时不发送idKey至鼠标端，导致这个加密过程无法完成；
       所以，鼠标response给主机的信息里面对主机不要求回发idKey；需要注意的是此时adv无法再采用whiteList功能了，因为没有主机的idkey了；
    7、某些BT4.1的电脑无法完成连接
       对于部分BT4.1的电脑的请求LL_LENGTH_REQ必须回应unknown，除此之外都会导致该电脑连接崩溃；
    8、连接过程可能失败
       如果在连接过程中，鼠标的motion不停的往主机发送，则有可能导致连接失败；
       所以需要阻止motion在完全完成连接后才能发送；

hs6621 CoreMark (hs6621总线设计有问题) :
    编译器：armclang 6.13
    优化选项：-Omax
    程序运行在：RAM
    cache: 16KB

    CPU     cache   ULP/LP     code in   data in   CoreMark   CoreMark/MHz
    ----------------------------------------------------------------------
    64MHz   yes     64/64MHz   ULP       LP        193        3.02
    64MHz   yes     64/64MHz   LP        ULP       186        2.91
    64MHz   no      64/64MHz   LP        ULP       179        2.79
    64MHz   no      64/64MHz   ULP       LP        150        2.34
    64MHz   yes     64/64MHz   ULP       ULP       186        2.91
    64MHz   yes     64/64MHz   LP        LP        193        3.02
    64MHz   no      64/64MHz   LP        LP        177        2.76
    64MHz   yes     2 /64MHz   ULP       LP        193        3.02
    64MHz   no      2 /64MHz   ULP       LP        5.5        0.09
    128MHz  yes     4 /128MHz  ULP       LP        387        3.02

hs6621c CoreMark
    编译器：armclang 6.13 (-Omax)
    优化选项：-Omax
        CPU     code in   data in   CoreMark   CoreMark/MHz
        ---------------------------------------------------
        32MHz   ROM       RAM       111        3.47

    编译器：armcc 5.06
    优化选项：-O3 -Otime --apcs=interwork
        CPU     code in   data in   CoreMark   CoreMark/MHz
        ---------------------------------------------------
        32MHz   ROM       RAM       84         2.6


vim: ft=help
