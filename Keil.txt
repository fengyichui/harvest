
Keil学习

1. 预定义变量
    - %L    Linker output file path (obj\output_file_name.axf, obj\output_file_name.lib)
    - @L    Linker output file name without extension (output_file_name)
    - $P    Project directory (C:\project\.)
    - %F    The currently active editor file (src\abc.c)
    eg:
        编译完成后拷贝库文件到指定目录
        $ cmd.exe /C copy "%L" "..\..\src\lib\keil\@L.lib"
    Reference: User's Guide/Utilities/Key Sequence for Tool Parameters ~

2. fromelf
    产生bin文件 >
    fromelf --bin --output gpio.bin gpio.axf
<    产生Intel Hex文件 >
    fromelf --i32 --output gpio.hex gpio.axf
<    产生源文件的汇编文件 >
    fromelf --text -c --output=outfile.asm infile.axf

3. 调试：初始化脚本文件
    位于： option\Debug\Initialization File
    作用： 用于调试初始化时，Keil自动加载的执行脚本，该脚本内可以做所有想做的事儿，如：remap、load程序到RAM、添加新的工具条
           Specifies a file that can contain Debug Commands, Debug Functions, debugger configuration settings, 
           and device initialization commands. For example, Toolbox buttons can be defined. Click Edit to open the file
    Reference：User's Guide\Dialogs\Project\Options\Debug ~

    预定义函数：(Ref: User's Guide\Debug Functions\Predefined Functions) >
    uchar _RBYTE (address)              Read a char from the memory address. 
    uint  _RWORD (address)              Reads a short int from the memory address. 
    ulong _RDWORD (address)             Reads a long from the memory address. 
    void  _WBYTE (address,              uchar val) Writes a char to the memory address. 
    void  _WWORD (address, uint val)    Write a short int to the memory address. 
    void  _WDWORD (address, ulong val)  Writes a long to the memory address. 
    double _sleep_ (ulong ms)           Delays execution for milli seconds. 
    void exec ("command_string")        Executes the debug command. 
    void execf ("fmt_string", ... )     Define debug commands with a variable component (for Cortex-M only). 
    void printf ("string", ...)         Works like the ANSI-C printf function. 
<    函数里的语法基本类似于C语言，区别在：
    Reference: User's Guide\Debug Functions\Differences Between µVision and C ~

    预定义命令 (Ref: User's Guide\Debugging\Debug Commands) >
    DEFINE      Create a Toolbox button. 
    EXIT        Exit debug mode. 
    FUNC        Create C-like functions for debugging. 
    INCLUDE     Read and execute commands in a command file. 
    KILL        Delete user- or signal functions and Toolbox buttons. 
    LOAD        Load object modules and HEX files. 
    LOG         Create log files, querie log status, and close log files for the Debug window. 
    MODE        Set the baud rate, parity, and number of stop bits for PC COM ports. 
    RESET       Reset the CPU, memory map assignments, and predefined variables. 
    SAVE        Save a memory range in an Intel HEX386 file. 
    SCOPE       Display address assignments of modules and functions of a target program. 
    SET         Set the string value for predefined variables. 
    SIGNAL      Display signal function status and remove active signal functions. 
    SLOG        Create log files, querie log status, and close log files for the Serial window. 

<    修改寄存器值： >
    PC = 0x08000010

<    函数： >
    定义：
    func void function_name (void)
    {
        printf("hello");
    }
    调用：
    function_name();

<    按钮： >
    KILL BUTTON *   //删除曾经所有的按钮
    DEFINE BUTTON "RESET", "RESET; PC = 0x100000D4; E INT 0x40000080 = 0xC0000000;"

<    Example1 (自动remap后load程序，不勾选"Load Application at Startup"): >
    // 5:ROM 6:RAM
    func void remap (int m)
    {
        _WDWORD(0x400e003c, _RDWORD(0x400e003c) | (1<<5));
        _WDWORD(0x400e003c, (_RDWORD(0x400e003c) & 0xfffffff0) | m | (1<<5));
    }
    remap(6);
    LOAD %L

<    NOTE: 这个Keil脚本有些奇奇怪该的问题，有个心理准备呦！


4. Load Application at Startup
    作用等同于命令：
    LOAD %L

5. Command Line
    UV4 [command] [projectfile] [options]
    Reference:  User's Guide\Command Line ~
    Example (build project): UV4.exe -b Blinky.uvproj -o Build_Output.txt

6. 多工程调试
    $ LOAD myprog.axf INCREMENTAL          # Load二进制程序、Load调试信息并添加到已有的符号表中
    $ LOAD myprog.axf NOCODE               # Load调试信息并替换已有的符号表
    $ LOAD myprog.axf INCREMENTAL NOCODE   # 仅Load调试信息到已有的符号表中
    $ LOAD myprog.axf                      # Load二进制程序、Load调试信息并替换已有的符号表

7. Linker
    - 指定Entry地址：--entry=Reset_Handler
    - 不删除未使用的段：--no_remove 
    - 符号文件：
        导出：linker框内加入: --symdefs=.\symdefs.o (多用于ROM符号导出)
        导入：文件列表内加入导出的目标文件:symdefs.o

8. link时，地址无关的scatter (常用于打ROM Patch) >
    LOAD 0 PI
    {
        PATCH 0 PI
        {
            *.o (PATCH, +FIRST)
            .ANY (+RO)
            .ANY (+RW +ZI)
        }
    }
    勾选 C/C++ 和 Asm 选项卡中的 Read-Only Position Independent / Read-Write Position Independent
    不勾选的话：
        不能使用全局变量，使用到全局变量的地方都要转换成const变量，然后再强制转换
        L6248E: <objname>(<secname>) in <attr1> region '<r1>' cannot have <rtype> relocation to <symname> in <attr2> region '<r2>'.
            This error can occur when you are trying to build position-independent (PI) code. Consider, for example the following code:
            #include <stdio.h>
            char *str = "test";
            int main(void)
            {
                printf ("%s",str);
            }
            When you compile and link this using:
            armcc -c --apcs /ropi/rwpi pi.c
            armlink --ropi --rwpi pi.o
            the linker reports the following error message:
            Error: L6248E: pi.o(.data) in PI region 'ER_RW' cannot have address type relocation to .conststring in PI region 'ER_RO'.
            This is because the compiler generates a global pointer str that must be initialized to the address of the string in the .conststring section. However, absolute addresses cannot be used in a PI system, so the link step fails.
            To resolve this, you must re-write the code to avoid the explicit pointer. You can do this using either of the following methods:
            Use a global array instead of a global pointer, for example:
            #include <stdio.h>
            const char str[] = "test";
            int main(void)
            {
                printf ("%s",str);
            }
            Use a local pointer instead of a global pointer, for example:
            #include <stdio.h>
            int main(void)
            {
                char *str = "test";
                printf ("%s",str);
            }
    勾选的话：
        有别的限制，生成的文件大小可能不包含全局变量的大小


9. 分散加载文件详解:

    +------------------------------------------+
    |  首先来个例子:                           |
    |  (功能: 中断向量表放到0x10000000, 紧跟   |
    |  中断向量表的是ResetHandle, 然后是其     |
    |  他的所有)                               |
    +------------------------------------------+
    |   LR_ROM1 0x10000000 0x10000             |
    |   {                                      |
    |       EXEC_APP_START 0x10000000 0x10000  |
    |       {                                  |
    |           *.o (RESET, +First)            |
    |           startup.o (RESET_HDL)          |
    |       }                                  |
    |                                          |
    |       EXEC_APP_OTHER +0                  |
    |       {                                  |
    |           .ANY (+RO)                     |
    |           .ANY (+RW +ZI)                 |
    |       }                                  |
    |   }                                      |
    +------------------------------------------+
    +-------------------------+-----------------------------+
    | 例子解释:               |                             |
    | LR_ROM1                 | <-- load_region_name        |
    |     0x10000000          | <-- start_address           |
    |         0x10000         | <-- max_size                |
    | {                       |                             |
    |    EXEC_APP_START       | <-- execution_region_name   |
    |         0x10000000      | <-- start_address           |
    |             0x10000     | <-- max_size                |
    |     {                   |                             |
    |         *.o             | <-- module_select_pattern   |
    |             (RESET,     | <-- input_section_pattern   |
    |              +First)    | <-- +input_section_attr     |
    |         startup.o       | <-- module_select_pattern   |
    |             (RESET_HDL) | <-- input_section_pattern   |
    |     }                   |                             |
    |                         |                             |
    |     EXEC_APP_OTHER      | <-- execution_region_name   |
    |         +0              | <-- +offset                 |
    |     {                   |                             |
    |         .ANY            | <-- module_select_pattern   |
    |             (+RO)       | <-- +input_section_attr     |
    |         .ANY            | <-- module_select_pattern   |
    |             (+RW +ZI)   | <-- +input_section_attr (2) |
    |     }                   |                             |
    | }                       |                             |
    +-------------------------+-----------------------------+

    分散加载能够将加载和运行时存储器中的代码和数据描述在被称为分散加载描述文件的一个文本描述文件中，以供连接时使用。

    a. 分散加载区 ~
        分散加载区域分为两类：
        加载区，包含应用程序复位和加载时的代码和数据。
        执行区，包含应用程序执行时的代码和数据。应用程序启动过程中，从每个加载区可创建一个或多个执行区。
        映象中所有的代码和数据准确地分为一个加载区和一个执行区。

    b. 分散加载文件语法 ~
        load_region_name  start_address | "+"offset  [attributes] [max_size]
        {
            execution_region_name  start_address | "+"offset  [attributes][max_size]
            {
                module_select_pattern  ["("
                                            ("+" input_section_attr | input_section_pattern)
                                            ([","] "+" input_section_attr | "," input_section_pattern)) *
                                       ")"]
            }
        } 

        load_region：          加载区，用来保存永久性数据（程序和只读变量）的区域；
        execution_region：     执行区，程序执行时，从加载区域将数据复制到相应执行区后才能被正确执行；
        load_region_name：     加载区域名，用于"Linker"区别不同的加载区域，最多31个字符；
        start_address：        起始地址，指示区域的首地址；
        +offset：              前一个加载区域尾地址＋offset 做为当前的起始地址，且"offset"应为"0"或"4"的倍数；
        attributes：           区域属性，可设置如下属性：
                               PI       与地址无关方式存放；
                               RELOC    重新部署，保留定位信息，以便重新定位该段到新的执行区；
                               OVERLAY  覆盖，允许多个可执行区域在同一个地址，ADS不支持；
                               ABSOLUTE 绝对地址（默认）；
        max_size：             该区域的大小； 
        execution_region_name：执行区域名；
        start_address：        该执行区的首地址，必须字对齐；
        +offset：              同上；
        attributes：           同上；
                               PI          与地址无关，该区域的代码可任意移动后执行；
                               OVERLAY     覆盖；
                               ABSOLUTE    绝对地址（默认）；
                               FIXED       固定地址；
                               UNINIT      不用初始化该区域的ZI段；
        module_select_pattern：目标文件滤波器，支持通配符 "*" 和 "?" ；
                               *.o匹配所有目标，* （或".ANY"）匹配所有目标文件和库。
        input_section_attr：   每个input_section_attr必须跟随在 "+" 后；且大小写不敏感；
                               RO-CODE 或 CODE
                               RO-DATA 或 CONST
                               RO或TEXT, selects both RO-CODE and RO-DATA
                               RW-DATA
                               RW-CODE
                               RW 或 DATA, selects both RW-CODE and RW-DATA
                               ZI 或 BSS
                               ENTRY, that is a section containing an ENTRY point.
                               FIRST，用于指定存放在一个执行区域的第一个或最后一个区域；
                               LAST，同上；
        input_section_pattern：段名；
                               1>. 汇编中指定段：
                                    AREA    section_name, CODE, READONLY
                               2>. C语言中指定段：
                                   a. #pragma arm section [sort_type[[=]"name"]] [,sort_type="name"]*
                                          sort_type:  code、rwdata、rodata、zidata
                                          如果"sort_type"指定了但没有指定"name"，那么之前的修改的段名将被恢复成默认值。
                                   b. #pragma arm section     // 恢复所有段名为默认设置。
                                      eg：#pragma arm section rwdata = "SRAM",zidata = "SRAM"
                                          static OS_STK  SecondTaskStk[256];              // "rwdata""zidata"将定位在"sram"段中。
                                          #pragma arm section                                 // 恢复默认设置
    c. 程序中对区域地址引用的方法 ~
        c.1 引用名字: ~
                Load$$region_name$$Base             Load address of the region.
                Image$$region_name$$Base            Execution address of the region.
                Image$$region_name$$Length          Execution region length in bytes excluding ZI length.
                Image$$region_name$$Limit           Address of the byte beyond the end of the non-ZI part of the execution region.
                Image$$region_name$$ZI$$Base        Execution address of the ZI output section in this region.
                Image$$region_name$$ZI$$Length      Length of the ZI output section in bytes (multiple of 4).
                Image$$region_name$$ZI$$Limit       Address of the byte beyond the end of the ZI output sectionin the execution region. 
                SectionName$$Base                   Input Address of the start of the consolidated section called SectionName.
                SectionName$$Limit                  Input Address of the byte beyond the end of the consolidated section called SectionName. 
                解释:
                    Load：          加载区，即存放地址；
                    Image：         执行区，即运行地址；
                    Base：          区首地址；
                    Limit：         区尾地址；
                    Length：        区长度；
                    region_name：   RO、RW、ZI、load_region_name、execution_region_name； 
                例如：
                    "RAM1"区域的首地址：      Image$$RAM1$$Base
                    上例中"sram"段首地址：    sram$$Base 

        c.2 汇编引用示例： ~
>
            IMPORT |Load$$Exec_RAM1$$Base|              // Exec_RAM1 为"RW"段
            IMPORT |Image$$Exec_RAM1$$Base|
            IMPORT |Image$$Exec_RAM1$$Length|
            IMPORT |Image$$Exec_RAM1$$Limit| 
            LDR  R0, = |Load$$Exec_RAM1$$Base|
            LDR  R1, = |Image$$Exec_RAM1$$Base|
            LDR  R2, = |Image$$Exec_RAM1$$Limit|
            CMP  R1,   R2
            LDRCC R3,   [R0], #4
            STRCC R3,   [R1], #4
            BCC  %b0
<
        c.3 C语言引用示例： ~
>
            extern unsigned char Load$$Exec_RAM1$$Base;
            extern unsigned char Image$$Exec_RAM1$$Base;
            extern unsigned char Image$$Exec_RAM1$$Length;
            void MoveRO(void)
            {
                unsigned char * psrc, *pdst;
                unsigned int  count;
                count = (unsigned int)   &Image$$Exec_RAM1$$Length;
                psrc  = (unsigned char *)&Load$$Exec_RAM1$$Base;
                pdst  = (unsigned char *)&Image$$Exec_RAM1$$Base;
                while (count--)
                {
                    *pdst++ = *psrc++;
                }
            }
<
    d. 表达式 ~
        - Expressions.
        - ScatterAssert function with load address related functions that take an expression as a parameter.
        - #define BASE_ADDRESS 0x8000
        - defined(version1) ? 0x8000 : 0x10000
        - ImageBase(region_name), ImageLength(region_name), ImageLimit(region_name)
        - AlignExpr(expr, align)
        - LoadBase(region_name), LoadLength(region_name), LoadLimit(region_name)
        NOTE: sct文件的行首必须加入: "#! armcc -E"

        - Example: >
            #! armcc -E
            #define START_ADDRESS  0x100000
            #define PAGE_ALIGNMENT 0x100000
            LR1 0x8000
            {
                ER0 +0
                {
                    *(InRoot$$Sections)
                }
                ER1 START_ADDRESS
                {
                    file1.o(*)
                }
                ER2 AlignExpr(ImageLimit(ER1), PAGE_ALIGNMENT)
                {
                    file2.o(*)
                }
                ER3 AlignExpr(ImageLimit(ER2), PAGE_ALIGNMENT)
                {
                    file3.o(*)
                }
            }

10. 编译器指定属性
    Function attributes ~
      - __attribute__((always_inline))
      - __attribute__((cmse_nonsecure_call))
      - __attribute__((cmse_nonsecure_entry))
      - __attribute__((const))
      - __attribute__((constructor[(priority)]))
      - __attribute__((format_arg(string-index)))
      - __attribute__((malloc))
      - __attribute__((noinline))
      - __attribute__((nonnull))
      - __attribute__((noreturn))
      - __attribute__((nothrow))
      - __attribute__((pcs("calling_convention")))
      - __attribute__((pure))
      - __attribute__((section("name")))
      - __attribute__((used))
      - __attribute__((unused))
      - __attribute__((visibility("visibility_type")))
      - __attribute__((weak))
      - __attribute__((weakref("target")))

    Type attributes ~
      - __attribute__((aligned))
      - __attribute__((packed))
      - __attribute__((transparent_union))

    Variable attributes ~
      - __attribute__((alias))
      - __attribute__((aligned))
      - __attribute__((deprecated))
      - __attribute__((packed))
      - __attribute__((section("name")))
      - __attribute__((used))
      - __attribute__((unused))
      - __attribute__((weak))
      - __attribute__((weakref("target")))

    Example: >
    // Function Attribute
    static int max(int x, int y) __attribute__((always_inline));
    {
        return x > y ? x : y; // always inline if possible
    }
    // Type Attribute
    struct __attribute__((packed)) foobar
    {
        char x;
        short y;
    };
    // Variable Attribute
    int x __attribute__((aligned (16)));
    // Multi Attribute
    uint32_t var[10] __attribute__((section(".xdata"), aligned(8)));

11. 在win10中，有时候进入调试或者下载模式时，keil直接退出的问题
    注册表中：计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers
    删除所有包含UV4.exe项

12. KEIL同时挂多个jlink:
    在option->debug->settings->jlink cmd 输入命令行：USBADDR = <address>

13. Segger
    a. Open Flashloader
        https://wiki.segger.com/Open_Flashloader
    b. Low power Debug
        https://wiki.segger.com/Generic_IDE#Low_power_debugging

14. 挂起某些编译的警告
    --diag_suppress=1,167,177,188,223

vim: ft=help
